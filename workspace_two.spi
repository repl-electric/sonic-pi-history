beat = 1.0/4.0

def live(name, opts={}, &block)
  idx = 0
  amp = if(opts[:amp])
    opts[:amp]
  else
    1
  end 
  x = lambda{|idx|
    with_fx :level, amp: amp do
      block.(idx)
      idx+=1
    end}
  live_loop name do |idx|
    x.(idx)
  end
end


live_loop :test do |h_inc|
  with_fx :level, amp: 1.0 do
    play degrees_seq(:Cs3, "86888555544443",
                     :Cs3, "333554444111",
                     :Cs2,  88818181818181,
                     :Cs2,  88838383838383,
                     :Cs2,  88858585858585,
                     :Cs2,  86888888888888,
                     :Cs3,  11)[h_inc],
      attack: 0.01, release: (ring beat, beat, beat*4, beat*4)[h_inc]
    sleep beat
    h_inc+=1
  end
end

live_loop :test2 do |h_inc|
  with_fx :level, amp: 1.0 do
    sync :test
    case h_inc % 32
    when 16..32
      cue :high
      play degrees_seq(:Cs3, 8)[h_inc], attack: 0.01, release: beat*4
      sleep beat
      play degrees_seq(:Cs3, 1)[h_inc], attack: 0.01, release: beat*4
      sleep beat
      play degrees_seq(:Cs2, 1)[h_inc], attack: 0.01, release: beat*4
    else
      play degrees_seq(:Cs2, 1)[h_inc], attack: 0.01, release: beat*4
      sleep beat
      play degrees_seq(:Cs2, 1)[h_inc], attack: 0.01, release: beat*4
      sleep beat
      play degrees_seq(:Cs2, 1)[h_inc], attack: 0.01, release: beat*4
    end
  end
  h_inc+=1
end

def chord_seq(pattern, root, s=nil)
  if !s
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
  end
  pattern.to_s.split("").map{|d| chord_degree(d.to_i, root, s)}
end


live_loop :test3 do |h_inc|
  with_fx :level, amp: 1 do
  sync :test
  #with_fx :lpf, cutoff: 80 do
    with_synth :tri do
        use_synth_defaults decay: beat*2, release: 1, attack: 0.2, amp: 3.9

   play chord_seq(:Cs4,
                       2222222,
                       3333333,
                       1111111,
                       2222222,
                       4444444,
                       4444555)[h_inc], attack: (ring 0.1)[h_inc], release: (ring beat,beat,beat,beat*4,beat*4,beat*4,beat*4)[h_inc], note_slide: 1.0
      sleep beat*2
    end
  #end
  h_inc+=1
  end
end

live_loop :test96 do |h_inc|
  with_fx :level, amp: 0 do
  sync :test
  #with_fx :lpf, cutoff: 100 do
    with_synth :dark_ambience do
      play degrees_seq(:Cs3,
1,
2,
3,
1,
2,
4,
5)[h_inc], attack: (ring 0.01)[h_inc], release: (ring beat*15,beat*15,beat*15,beat*15,beat*15,beat*30,beat*30)[h_inc], note_slide: 1.0
      sleep beat*7
    end
 # end
  h_inc+=1
  end
end

live_loop :test99 do |h_inc|
  sync :time
  with_fx :lpf, cutoff: 0 do
    with_synth :saw do
      case h_inc % 32
      when 16..32
        play degrees_seq(:Cs3, 1)[h_inc], attack: 0.1, release: (ring beat*1)[h_inc], note_slide: 1.0
      else
        play degrees_seq(:Cs2, 1)[h_inc], attack: 0.1, release: (ring beat*1)[h_inc], note_slide: 1.0
      end
      #sleep beat*2
    end
  end
  h_inc+=1
end

live_loop :test4 do |h_inc|
  sync :test
  with_fx(:reverb, room: 1, mix: 0.6, dry: 0.1){
    sample (ring :drum_tom_lo_soft, :drum_tom_mid_soft, :drum_tom_hi_soft)[h_inc], rate: 0.6, amp: 1.0, start: 0.05
  }
  sleep beat*14
  h_inc+=1
end

live_loop :test4 do |h_inc|
  8.times{sync :test}
  #sample :elec_lo_snare, amp: 0.01, start: rand(0.1)
end

set_volume! 1