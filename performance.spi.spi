#camlogo logo: 1, crazy: 1, off: 1.0
#bitsea_on :cs4
#focus
#stop
    def rootz(note_seq)
      note_seq.map{|n|
        if n
          note(n)
        else
          nil
        end
      }.compact.sort{|n1,n2| n1 <=> n2 }[0]
    end

    live_loop :pi, sync: :hit do;tick;dcam3
      stop
      with_bpm 63.5 do #63.5
        score=(ing
          D4 Cs4 _ A3 _ E4 _ A4 A4 A4 A4 A4
          D4 Cs4 _ A3 _ B3 _ A4 A4 A4 Fs4 A4
          )
        note=score.look
        future_note=score.look(offset: 1)
        operator note
        callstack note,(ing 70 65 60).look, sus: 2

        sleep 1/2.0
        chd = find_chord future_note
        if spread(1,2).rot(1).look
          with_transpose 0 { zero chd[1],1, sus: 12 }
          with_transpose -12 { zero chd[2],1, sus: 12 }
          with_transpose -24 { zero chd[0],1, sus: 12 }
        else
          with_transpose 12 { zero chd[0],1,sus: 12 }
        end

        sleep 1/2.0
        eek note, mode: 2, sus: 3 if spread(1,3).look

        if note == D4
          64.times{|n|
            sleep 0.125
            corrupt :E3, sus: 0.25 if n % 8 == 0
            sleep 0.125
            corrupt :E4, sus: 4.0 if n % 8 == 0
          }
          stop
        end


        sleep 1/4.0
      end
    end
cue :hit


live_loop :go, sync: :unsyncable do
      #      stop
      dcam4 true
      dviz :breath, throttle: 1.0
      tick
  score=(ing
        [:b2  :d5 :fs3]        Zz
        [:fs2  :a4 :cs3]       Zz
        [:a2  :b4  :e4]
        [:d3  :fs5 :a3 :cs5]   Zz
        [:e2  :gs4 :b3]
        [:b2  :d5  :fs3 :cs4]  Zz
        [:fs4 :a4  :cs3]       Zz


        ).look

      rev :B5, 2 if spread(1,6).look
  #callstack rootz(score), (ring 60,68).look
  score.each_tick(:in){|n|
#    qbitsea n, 2.0*(ing 80 70 85 70).look(:in), mode: 0, cutoff: 1.0, sus: 2.5
  }
      exception rootz(score), atk: 0.01, more: 0.0,
                              shape: 1.0, wet: 0.0
      sleep 1
      null rootz(score), 50
      sleep 1
end
bitsea_cc motion: 0.10  #╟▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
bitsea_cc octave: 0.50  #╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
#bitsea_cc formant: 0.00 #╟▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢

#qbitsea_cc motion: 0.20
electric
#invcol
#bitsea_on :cs5

live_loop :breath, sync: :unsyncable do
      with_fx :echo, mix: 1*(ring 0.025+rand*0.1,0.055+rand*0.1,0.03,0.02,0.01).look, phase: (ring 1/4.0, 1/8.0).look do
        stop
    8.times{tick;
      #qbitsea :A2 if spread(7,11).look
      #qbitsea :e3, sus:0.125 if spread(3,8).look
      #eek :a2, sus: 1.0, mode: 0 if spread(1,12*2).rot(2).look
      #corrupt :A2
      pp=(ing
        _
        ).look
      #0/0.ss
      smp_dust(pp)
      mt mt_pat.look.look, accent=(line 75, 85, 16*4).look, 100
      mt_cc morph: ((line 0.0, 1.1,16*16*2)+(line 1.1, 0.0, 16*16*2)).look
      s=(ing
        2 _ _ _  5 _ _ _    5 _ _ _      _ _ _ _
        5 _ _ _   _ _ _ _   5 _ [2] 3    _ [5] 5 5
        ).look
      mt s, accent=(line 75, 85, 16*4).look, 100

      s=strpat("[5]p5p5p5p 5p5p5[5]5p")
      #mt s.look,accent=(line 85,127,64).look, 120

      sleep 1/8.0
    }
  end
end
    live_loop :kicker, sync: :unsyncable do
      stop
  tick
      kick_machine x=(ing
      [KT[1]] _ TS[8] _   _ _ _ _  K3 _ _ _   _ _ _ _
      K1 _ _ _   _ _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _   %l{TC[6]} _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _   _ _ _ _  K3 _ %l{TC[6]} _   _ _ _ _

      K1 _ _ _   _ _ _ _  K3 _ _ _   _ _ _ _
      K1 _ _ _   _ _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _   %l{TC[6]} _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _   _ _ _ _  K3 _ %e{TC[6]} _   _ _ _ _

      ).map{|c| look % 64 == 0 ? c : c}.look, def: 8, accent: 2
      yes{
      if x && spread(1,64).rot(0).look
        bitsea :fs4, sus: 4.0
        cue :hit
        stop
      end}
      stop

    p=(ing
      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      [TS[49]] _ _ TS[12]    _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TT[49] _ _ TS[12]      _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _
      )

    p=p.look
    #p=_
    fx=:lpf
    accent = (ing 0.2 0.2 0.3 0.5).look
    attack = 0.0
    r = 1.0
    if p && p.is_a?(Array)
      p = p[0]
      accent=accent*1.5
    end
    if p
      with_swing(0.01) do
        with_fx(fx, phase: (ring 1/4.0,1/4.0,1/8.0).look){
          at{
            sleep 0.5
            viz :sea, height: 0.3
            viz :sea, noise: 10.0
            sleep 0.125
            viz :sea, height: 0
            viz :sea, noise: 0.01
          }
          smp p, amp: 3*accent, rate: r, attack: attack
        }
      end
    end

  sleep 1/8.0
end




live_loop(:unsyncable) do; sleep 1.0 end
