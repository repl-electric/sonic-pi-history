beat = 1/1.0

def degrees_seq(pattern, root, s=nil)
  if !s
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
  end
  pattern.to_s.split("").map{|d| degree(d.to_i, root, s)}
end

def chord_seq(pattern, root, s=nil)
  if !s
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
  end
  pattern.to_s.split("").map{|d| chord_degree(d.to_i, root, s)}
end

wood_s = "/Users/josephwilk/Dropbox/repl-electric/samples/Analog\ Snares\ \&\ Claps/17\ \ EMT140\ \(1\).wav"

live :drums do |n|
 # with_fx(:lpf, cutoff: 100){sample :drum_heavy_kick}
  cue :start
  cue :half_hit
  sleep beat/2
  cue :half_hit
  sleep beat/2
  cue :half_hit
  sleep beat/4
  cue :quarter_hit
  sleep beat/4
  cue :quarter_hit
  sleep beat/2
  n+=1
end

live :pulse3, amp: 1.0 do |p_inc|
 sync :half_hit, :quarter_hit
 with_synth :hollow do
   sample wood_s, amp: 0.2, start: 0.1
   play (ring *degrees_seq(1113111311131114, :Cs3))[p_inc], attack: 0.01, release: beat/2, amp: 4.00
   with_synth :growl do
   #play (ring *degrees_seq(1113111311131114, :Cs5))[p_inc], attack: 0.001, release: beat/2, amp: 4.00
   end
   #sleep (ring beat/2, beat/2, beat/4, beat/4)[p_inc]
   sleep beat/4
 end
 p_inc+=1
end

live :deep, amp: 1.0 do |d_inc|
  2.times{sync :start}
  with_synth :beep do
    play (ring *degrees_seq(1, :Cs2))[d_inc], release: beat*4
  end
  d_inc+=1
end

live_loop :holloweded do |z_inc|
  hollowed_synth (ring *degrees_seq(1, :Cs3, :major))[z_inc]
  sleep beat
  z_inc+=1
end

set_volume! 4.0