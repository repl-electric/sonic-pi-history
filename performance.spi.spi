#cam4 true
#stop

#bitsea_on :cs4

bitsea_cc motion: 0.10  #╟▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
bitsea_cc octave: 0.57  #╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
#bitsea_cc formant: 0.36 #╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
#invcol 1.0
#electric
#viz :alive, height: 0.0
#terrain 0.2
#cam3
#cue :waitforit
#alive thick: 0.02
qbitsea_cc oct: 0.50
qbitsea_cc drive: 1.00
qbitsea_cc charge: 0.53
qbitsea_cc fm: 1.00
qbitsea_cc wav: 0.90
qbitsea_cc wav_amp: 0.50
qbitsea_cc atk: 0.00
qbitsea_cc mod: 0.80
qbitsea_cc motion: 0.24
qbitsea_cc formant: 0.36
qbitsea_cc mul: 0.00
qbitsea_cc bass: 1.00

eq lo: 0.00
eq hi: 0.00




#cam4
#cam1
#camend
#stop

#alive gravity: 1.0 #FUN

live_loop :go do
  #  stop
  tick
  #dcam1
  score=(ing
#    [:a2  :cs5 :e3]        Zz
 #   [:fs2 :a4 :cs4]       Zz
    [:a2  :cs3  :e3]
    [:d2  :fs2 :a3 :e3]   Zz
 #   [:e2  :gs4 :b3]
 #   [:a2  :cs5  :e3 ]  Zz
#    [:fs4 :a4  :cs4]       Zz

    ).look
  dcam4
  #invcol 1.0
  #callstack score[0], 60
  score.each_tick(:in){|n|
    qbitsea n,2.0*(ing 80 70 85 70).look(:in), mode: 0, cutoff: 1.0, sus: 2.5
  }
#  whitespace score[-1],1, sus: 12
  pf= 1.8
  i=(method :operator)
  at{
    i.call(score[0], 60*pf, sus: 4)
    sleep 0.5
    i.call(score[1], 50*pf, sus: 4)
    sleep 0.25
    i.call(score[2], 55*pf, sus: 4)
        sleep 0.25
    i.call(score[3], 70*pf, sus: 2)
        sleep 0.25
    i.call(score[4], 30*pf, sus: 8)
        sleep 0.25
    i.call(score[5], 30*pf, sus: 8)
        sleep 0.25
  }

  operator :fs3

  # if score.length > 1
  #   at{sleep 1/8.0*3
  #     exception score[0], atk: 0.01, form: 1.0
  #     sleep 1/8.0*3
  #     #sleep 1/8.0*3
  exception score[0], atk: 0.01, form: 1.0
  #   }
  #alive spike: 0.9
  null score[0],100, sus: 2
  #end
  alivecol 0.0

  #viz :alive, x: 1.0+rand
#  bitsea :A2
  #verb_slice Drip[/effect/].look if spread(1,3).look
  #alive light: rand*0.1
  #alive motion: 0.8
  alivecol 0.2
  16.times{tick(:k);
    k=(ing
       K1 _ _ _  _ _ _ _

      # [KT[1]] _ _ _  _ _ _ _          K3 _ _ _   _ _ _ T1
      # K1 _ _ _       _ _ _ _          K3 _ _ _   _ _ _ T1
      # K1 _ _ _       %l{TC[6]} _ _ _  K3 _ _ _   _ _ _ T1
      # K1 _ _ _       _ _ _ _          K1 _ %e{TC[6]} _   _ _ [F1 0.99] _
      )

    #k=k.map{|cell| look(:k) % 32 == 0 ? cell : _}
    #focus if k
    kick_machine x=k.look(:k), def: 8, accent: 2
    #dterrain 0.5 if x
    delectric 5
    #zero_x
    sleep 1/8.0
    if k.look(:k) == [KT[1]]
      cue :sshh
#      sync :waitforit
    end
  }
  #sleep 2
end

stop

#crashcam3 0.4
#cam3 true
cam3
live_loop :pi do
 # stop
  tick
  #  zero_x
  with_bpm 63.49 do
    score = (ing
      :d4 :cs4 _ :a3 _ :e4 _ :A4 :A4 :a4 :A4 :A4
      :d4 :cs4 _ :a3 _ :b3 _ :A4 :A4 :a4 :fs4 :A4
      )
    n = score.look
    operator n, 70
    callstack n, 10+(ing 70 65 55).look * 1.0, sus: 4/2.0
    if score
      delectric 5#0 if note == :d4
    end
    sleep 1/2.0

    c = chord(score.look(offset: 1),ct(score.look(offset: 1)))
    zero c[1],1, sus: 12  if spread(1,2).rot(1).look
    with_transpose -12 {zero c[2],1, sus: 12  if spread(1,2).rot(1).look}
    with_transpose -24 {zero c[0],1, sus: 12  if spread(1,2).rot(0).look}
    with_transpose 0   {zero c[-1],1, sus: 12  if spread(1,2).rot(1).look}

    sleep 1/2.0
    corrupt note(n)-12, 10, mode: 2
    eek n, sus: 6, mode:2 if spread(1,3).look
    sleep 1/4.0

    if n == :d4
      64.times{|x|
        sleep 0.25/2.0
        corrupt :e5,10, mode: 0, sus: 0.125 if x % 8
        sleep 0.25/2.0
        corrupt :e4, mode: 0, sus: 4 if x % 16
        sleep 0.5
      }
      stop
    end

  end
end


#zero_on :fs5
zero_cc pulse: 0.55
zero_cc more:  0.77
zero_cc noise: 0.45
zero_cc wet:   1.00
zero_cc amp: 0.80




live_loop :glitch, sync: :go do
  tick
  sync :waitforit
  p=(ing
    _ _ _ _                _ _ _ _
    _ _ _ _                _ _ _ _
    [TS[49]] _ _ TS[12]    _ _ _ _

    _ _ _ _                _ _ _ _
    _ _ _ _                _ _ _ _
    TS[7] _ _ _            _ _ _ _

    _ _ _ _                _ _ _ _
    _ _ _ _                _ _ _ _
    TT[49] _ _ TS[12]      _ _ _ _

    _ _ _ _                _ _ _ _
    _ _ _ _                _ _ _ _
    TS[7] _ _ _            _ _ _ _
    )

  p=p.look
  #p=_
  fx=:lpf
  accent = (ing 0.2 0.2 0.3 0.5).look
  attack = 0.0
  r = 1.0
  if p && p.is_a?(Array)
    p = p[0]
    accent=accent*1.5
  end
  if p
    with_swing(0.01) do
      with_fx(fx, phase: (ring 1/4.0,1/4.0,1/8.0).look){
        at{
          sleep 0.5
          viz :sea, height: 0.3
          viz :sea, noise: 10.0
          sleep 0.125
          dviz :sea, height: 0
          viz :sea, noise: 0.01
        }
        smp p, amp: 3*accent, rate: r, attack: attack
      }
    end
  end
  sleep 1/8.0
end


#zero_on :fs4


#viz :sea, size: 0.4

live_loop :By_the_light_of_the_terminal, sync: :go do
  with_fx :echo, mix: ring(0.025+rand*0.1,0.055+rand*0.1,0.03,0.02,0.01).look, phase: ring(1/4.0, 1/8.0).look do
    #unity "/postfx/color",0.0
    verb_slice Drip[/effect/].look,amp: 0.1 if spread(1,3).look
    8.times{tick;
      pp = (ing
        _ _ _ _    _ _ _ _     _ _ _ _    _ _ _ _
        _ _ _ _    _ _ D1 _    _ _ _ _   _ _ _ _
      ).look
      #pp=_
 #     dterrain 0.5 if pp
#      smp_dust(pp, rate: rand(0.025), amp: 1.0)
      s1 = (ing
        _ 5   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   5 _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   _ _   5 _  _ _  5 _  _ _
       )
      s2 = (ing
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   5 _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        )
      s3 = (ing
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        )
      s=(knit s2,16*4,s3,16*4, s1,16*4).look
      #s=_
      #mt s.look, accent=(line 75, 85, 16*4).look, 100
      mt_cc morph: ((line 0.0, 1.1,16*16*2)+(line 1.1, 0.0, 16*16*2)).look
      s=(ing
        2 _ _ _  5 _ _ _    5 _ _ _      _ _ _ _
        5 _ _ _   _ _ _ _   5 _ [2] 3    _ [5] 5 5
        ).look
      accent=110
      #s=_
      if s
       # mt s, accent=120, 127
      end
      if (s=(ing
            [5] _ 5 _ 5 _ 5 _   5 _ 5 _ 5 [5] 5 _
            ).look)
        s=_
        #mt s,accent=(line 85,127,64).look, 120 if s
      end
      sleep 1/8.0
    }
  end
end
