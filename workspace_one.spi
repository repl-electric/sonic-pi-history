  n = {1 => :Fs3, 2 => :Gs3, 3 => :As3, 4  => :B3, 5 => :Cs4, 6 => :Ds4, 7 => :Es4}
  n2 = {1 => :Fs2, 2 => :Gs2, 3 => :As2, 4  => :B2, 5 => :Cs3, 6 => :Ds3, 7 => :Es3}

      #I ii iii IV V vi  viio
  x2 = (1..7).map{|d| chord_degree(d, :Fs2, :major)}.ring
  x3 = (1..7).map{|d| chord_degree(d, :Fs3, :major)}.ring

  s22 = (1..7).map{|d| chord(n2[d], :sus2)}.ring
  s24 = (1..7).map{|d| chord(n2[d], :sus4)}.ring

  s22 = (1..7).map{|d| chord(n2[d], :sus2)}.ring
  s24 = (1..7).map{|d| chord(n2[d], :sus4)}.ring


  s32 = (1..7).map{|d| chord(n[d], :sus2)}.ring
  s34 = (1..7).map{|d| chord(n[d], :sus4)}.ring
  s327 = (1..7).map{|d| chord(n[d], "7sus2")}.ring
  s347 = (1..7).map{|d| chord(n[d], "7sus4")}.ring

  s227 = (1..7).map{|d| chord(n2[d], "7sus2")}.ring
  s247 = (1..7).map{|d| chord(n2[d], "7sus4")}.ring

  p5 = (1..7).map{|d| chord(n[d], :M7)}.ring

["experiments", "log"].each{|f| load "/Users/josephwilk/Workspace/repl-electric/live-coding-space/lib/#{f}.rb"}

bar = 1.0
use_bpm 60

live :indeterminism, amp: 0.0 do
  4.times{sync :next}

  with_fx(:distortion, mix: 1.0, distort: 0.8) do |fx_r|
    with_synth(:hollow) do
      play deg_seq(%w{Fs4 1 3}).tick, decay: bar*2, attack: 4, amp: 0.4, release: 1.0
    end
    notes = dice(6) > 3 ? deg_seq(%w{Fs3 1}) : deg_seq(%w{Fs4 1})
    with_fx(:reverb, room: 0.9) do
      with_synth(:dark_ambience) do
      #  play notes.tick(:note), decay: bar*6, attack: 1, amp: 1.0, release: 2.0
      end
    end

    4.times{
      sleep bar/4.0
      control fx_r, distort: (ring 0.8, 0.8, 0.5, 0.0).tick(:distory)
    }
  end

  4.times{sync :next}
  i_deter(deg_seq(%w{Fs4 1*7 _ 3*7 _}).tick,
          deg_seq(%w{Fs4 34 -5 4}).stretch(4).tick)
end

_=nil

live_loop :next, amp: 1.0 do
  2.times{
    cue :half; cue :quarter; cue :eigth
    sample Mountain["pebble",0], start: rrand(0.0,0.01), rate: 1.0, amp: 0.3
    sleep bar/8.0; cue :eigth
    sleep bar/8.0; cue :eigth; cue :quarter
    sleep bar/8.0; cue :eigth; 
    sleep bar/8.0; cue :eigth; cue :quarter  
    cue :half
    sleep bar/8.0; cue :eigth
    sleep bar/8.0; cue :quarter; cue :eigth
    sleep bar/8.0; cue :eigth
    sleep bar/8.0; cue :quarter; cue :eigth
  }
end

bar =1.0
live_loop :playz do
  with_fx(:level, amp: 1.0) do
 sync :eigth

#(knit 0.25,7, 1.0,1, 0.5,1, 1.0,1, 0.25,6, 1.0,1)

notes = (ring 
       :Fs3, 0.25, s32[1][1..-1], 0.25, :Fs3, 0.25, s32[1][0], 0.50, s24[4][0], 1.0, :As3, 0.25, :Ds3, 0.25, [chord(:As3, "m7+5"), chord(:As3, "m+5"), chord(:As3, "m+5", invert: [0,-1].choose)].choose, 1.0,
       :Fs3, 0.5,  s32[0], 0.25, chord(:As4, "m", invert: -3), 0.25, :As3, 0.25, :Fs3, 0.25, s32[0], 0.25, :Fs3,0.25, :As3, 1.0)

notes = (ring 
       :Fs3, 0.25, s32[1][1..-1], 0.5, :Fs3, 0.25, s32[3][0], 1.0, 
       :Cs4, 0.25, s32[3][1..-1], 0.5, [chord(:As3, "m7+5"), chord(:As3, "m+5"), chord(:As3, "m+5", invert: [0,-1,1].choose)].choose, 1.0, :Ds3, 0.25,:Cs3, 0.25,
       :Cs3, 0.25, chord(:Ds4, "sus4", invert: -2.0), 0.5, [chord(:Ds3, "m7+5"), chord(:Ds3, "m+5"), chord(:Ds3, "m+5", invert: [0,-1,1].choose)].choose, 1.0, :Ds3, 0.25,:Cs3, 0.25,    
       :Fs3, 0.5,  s32[0], 0.25, chord(:As4, "m", invert: -3), 0.5, :As3, 0.25, :Fs3, 0.25, s32[0], 0.5, :Fs3,0.25, chord(:Gs3, "m7+5", invert: 0.0), 1.0)


    notes = (ring x3[0], 1.0, :Es3, 0.5, :Ds3, 0.5, :Fs4, 1.0, :Cs4, 0.5,
                  x3[0], 0.5, :Ds3, 0.5, :Ds3, 0.5, :Ds3, 1.0, :B3, 1.0,

                  x3[0], 1.0, :As3, 0.5, :Ds3, 0.5, :Fs3, 1.0, :Cs3, 0.5,
                  x3[0], 0.5, :As3, 0.5, :Ds3, 0.5, :Ds3, 1.0, :B3, 1.0)


    notes = (ring 
                  chord(:Fs3,"M"), 1.0, chord(:Es3,"dim"), 0.5, chord(:Ds3,"m"), 0.5, [chord("Fs4","M"), chord("Fs4","M", invert: -1), chord("Fs4","M", invert: -2), chord("As3","m7+5", invert: 0)].choose, 1.0, chord("Cs4","M"), 0.5,
                  chord(:Fs3,"M"), 0.5, chord(:Ds3,"m"), 0.5,   chord(:Ds3,"m"), 0.5,  chord(:Ds4,"m+5"), 1.0, chord("As3","m"), 1.0,

                  chord(:Fs3,"M"), 1.0, chord(:As3,"m"), 0.5, chord(:Ds3,"m"), 0.5, chord("Fs3","M"), 1.0, chord("Cs3","M"), 0.5,
                  chord(:Fs3,"M"), 0.5, chord(:As3,"m"), 0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m", invert: 1), 1.0, chord(:B3,"M"), 1.5,

                 chord(:Fs3,"M"), 1.0, chord(:As3,"m+5"), 0.5, chord(:Ds3,"m"), 0.5, chord("Fs3","M"), 1.0, chord("B3","M"), 0.5,
                 chord(:Fs3,"M"), 0.5, chord(:As3,"m+5"), 0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m"), 1.0, chord(:B3,"M"), 1.0,

                  chord("Fs3","sus4"), 1.0, chord("As3","m"), 0.5, chord(:Ds3,"m"),0.5, [chord(:As3, :m, invert: 0), 
                                                                                        chord(:As3, :minor7, invert: 0)].choose, 1.0, chord("As3","m"), 0.5,
                  chord("Fs3","M"),    0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m"), 1.0, chord("B3","M"), 1.0,

                  chord("Fs3","M"), 1.0, chord(:As3,"m"), 0.5, chord(:Ds3,"m"), 0.5, chord("Fs3","M"), 1.0, chord("Cs3","M"), 0.5,
                  chord("Fs3","M"), 0.5, chord(:As3,"m"), 0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m"), 1.0, chord(:B3,"M"), 1.0,

                  chord("Fs3","M"), 1.0, chord(:As3,"m+5"), 0.5, chord(:Ds3,"m"), 0.5, chord("Fs3","M"), 1.0, chord("B3","M"), 0.5,
                  chord("Fs3","M"), 0.5, chord(:As3,"m+5"), 0.5, chord(:Ds3,"m"), 0.5, chord(:Ds3,"m"), 1.0, chord(:B3,"M"), 1.0
)

  
notes = (ring :FS3,  1.0, :Es3, 0.5, :Ds3, 0.5, :AS3,1.0, :Cs4, 0.5, :FS3,  0.5, :Ds3, 0.5, :Ds3, 0.5, :DS4, 1.0, :Cs4, 1.0

 )


notes = (ring :FS3,  0.5, :Fs3, 0.5, :B3, 1.0, 
              :BS3,  0.5, _, 0.5,    :Fs3, 1.0,
              :Fs3,  0.5, :Fs3, 0.5, :As3, 1.0,


 )






# :As3,0.5, :Cs4, 2.0, :B3, 1.0,

#                   :Fs4, 0.25, :Fs4,0.5, :As4, 1.0, :Gs4, 1.0


#                   :Fs3, 0.5, :Fs3,0.5, :Cs4, 1.0,
 #)


     with_transpose(0) do
     #with_fx((knit :reverb, 2, :echo, 2).tick(:fx)) do
          #play notes.tick(:notes), release: notes.tick(:notes)
          #sleep notes.look(:notes)
          n = notes.tick(:notes)
          s = notes.tick(:notes)
          play n, release: s
           sleep s
#          i_deter(n,_, release: notes.tick(:notes)*1.0, werble: true, damp_time: (notes.look(:notes)/3.0), attack: 0.01, amp: 1.0)
     #end
     #sleep notes.look(:notes)
     puts note_inspect(n, "melo:")
end
end
end


live_loop :movement do
  pick = [6,5].choose
  3.times{
    sample Mountain[/microperc/i, pick]
    sync :next
  }
  with_fx((knit :none, 3, :echo, 1).tick) do
    sample Mountain[/microperc/i, [6,5]-[pick]]
    sync :next
  end
end


with_fx :distortion, mix: 0.1 do
with_fx(:pitch_shift, window_size: 4.0) do
live_loop :rumbling_loops, auto_cue: false do |idx|;with_fx :level, amp: 0.0 do
with_fx :reverb, mix: 0.2, damp: 0.3 do |fx_reverb|;
    3.times{sync :next}
comment do
    notes = (knit "Cs3",2, "Gs2",2, "As2",2,
                  "Cs3",2, "Gs2",2, "As2",2,
                  "B2",2,  "Gs2",2, "As2",2)
end

    notes = (knit chord(:As1,:m,    invert: 2)[0], 1,
                  :Cs2,                            2,
                  chord(:Ds2,:m,    invert: 0)[0], 2,
                  chord(:Es1, 'dim',invert: 0)[0], 2,
                  chord(:Es1,'dim', invert: 2)[0], 2,
                  :Fs1,                            2,
                  _,1,:Fs2,1,
                  chord(:B1,:M,     invert: -1)[0],3)

    note = notes.tick(:a)

    note = (ring :F1,  :As2, :Ds2,
                  :F1, :As2, :Ds2,
                  :F1, :As2, :Fs2).tick(:bass)

  
    puts "BASS[#{note_info(note||0)}]"

    sleep bar/2.0
    #(ring 1,0).tick(:ti).times{with_fx(:pitch_shift, mix: 1.0, pitch: 0.025){with_fx(:slicer, mix: 0.5, phase: 0.025, probability: 0.5){sample Heat[/stacked_bells/i,note_to_sample(notes.reverse.look(:a),1)], amp: 1.5, attack: 0.2}}}
    #(knit 1,1).tick(:heat).times {with_fx(:reverb){sample Heat[/low_pad/i,note_to_sample(note,1)], amp: 1.0}}

          with_transpose(-12) do
            i_bass(note)

    (ring 1,0).tick(:double).times do
     # with_fx(:echo, decay: 2.0){sample Frag[/coil/i, /f#/i].tick(:coil), amp: 0.5}
      #sample Frag[/coil/i,11], amp: 1.0
              with_synth [:pnoise, :prophet][0] do
                play note, amp: 0.7, release: (knit bar,1).tick(:Bass), attack: 0.01, cutoff: 60
    end
    end
          end

    1.times{sync :next}

          with_transpose(-36) do
            i_bass(note)
          end

    6.times{
      control fx_reverb, damp: (rrand 0.0,1.0)
      sleep bar/8.0
    }
end;end
idx += 1
end;end;end


live_loop :kick do
  sample Mountain[/subkick/i, 2], amp: 0.0
  4.times{sync :next}
end


live_loop :crack do
  sample Mountain[/cracklin/i, 0], rate: 0.9, amp: 0.2
  sleep sample_duration(Mountain[/cracklin/i, 0])
end