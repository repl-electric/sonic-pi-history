bar = 1.0
use_bpm 60

live :indeterminism, amp: 1.0 do
  4.times{sync :next}

  with_fx(:distortion, mix: 1.0, distort: 0.8) do |fx_r|
    with_synth(:hollow) do
      play deg_seq(%w{Fs4 1 3}).tick, decay: bar*2, attack: 4, amp: 0.4, release: 1.0
    end
    notes = dice(6) > 3 ? deg_seq(%w{Fs3 1}) : deg_seq(%w{Fs4 1})
    with_fx(:reverb, room: 0.9) do
      with_synth(:dark_ambience) do
      #  play notes.tick(:note), decay: bar*6, attack: 1, amp: 1.0, release: 2.0
      end
    end

    4.times{
      sleep bar/4.0
      control fx_r, distort: (ring 0.8, 0.8, 0.5, 0.0).tick(:distory)
    }
  end

  4.times{sync :next}
  i_deter(deg_seq(%w{Fs4 1*7 _ 3*7 _}).tick,
          deg_seq(%w{Fs4 34 -5 4}).stretch(4).tick)
end


live_loop :next, amp: 1.0 do
  2.times{
    cue :half;     cue :quarter;
    sample Mountain["pebble",0], start: rrand(0.0,0.01), rate: 1.0, amp: 0.3
    sleep bar/4.0; cue :quarter
    sleep bar/4.0; cue :quarter
    cue :half;  :quarter
    sleep bar/4.0; cue :quarter
    sleep bar/4.0
  }
end

#1*7 _ 3*7 _
#34 -5 4

live_loop :melody do
  #8 iterations
  n = {1 => :Fs3, 2 => :Gs3, 3 => :As3, 4  => :B3, 5 => :Cs4, 6 => :Ds4, 7 => :Es4}
  n2 = {1 => :Fs2, 2 => :Gs2, 3 => :As2, 4  => :B2, 5 => :Cs3, 6 => :Ds3, 7 => :Es3}

      #I ii iii IV V vi  viio
  x2 = (1..7).map{|d| chord_degree(d, :Fs2, :major)}.ring
  x3 = (1..7).map{|d| chord_degree(d, :Fs3, :major)}.ring

  s22 = (1..7).map{|d| chord(n2[d], :sus2)}.ring
  s24 = (1..7).map{|d| chord(n2[d], :sus4)}.ring

  s32 = (1..7).map{|d| chord(n[d], :sus2)}.ring
  s34 = (1..7).map{|d| chord(n[d], :sus4)}.ring
  s327 = (1..7).map{|d| chord(n[d], "7sus2")}.ring
  s347 = (1..7).map{|d| chord(n[d], "7sus4")}.ring

  s227 = (1..7).map{|d| chord(n2[d], "7sus2")}.ring
  s247 = (1..7).map{|d| chord(n2[d], "7sus4")}.ring

  p5 = (1..7).map{|d| chord(n[d], :M7)}.ring

  r = (knit 0.5, 16, 4.0,1).tick(:r)
                 

  start_notes = (ring :Fs2, :Cs3, :As3, :Ds4)
  end_notes =  (ring :Fs3)
 
  (knit 1,4,4,1).tick(:time).times { sync :quarter}
  #r = (knit 0.5, 7, 1.0,1).tick(:r)

  i_deter( start_notes.tick(:d), end_notes.tick(:e), attack: 0.05, release: r, amp: 0.5)
   puts note_inspect(start_notes.look(:d))

end


live_loop :kick do
  sample Mountain[/subkick/i, 2], amp: 0.5
  4.times{sync :next}
end

live_loop :movement do
  pick = [6,5].choose

  sample Mountain[/microperc/i, pick]
  sync :next
  sample Mountain[/microperc/i, pick]
  sync :next
  sample Mountain[/microperc/i, pick]
  sync :next
  with_fx((knit :none, 3, :echo, 1).tick) do
    sample Mountain[/microperc/i, [6,5]-[pick]]
    sync :next
  end
end

live :missing_semi_colon, amp: 1.0 do
    2.times{sync :start}
    sample (knit Mountain["microperc_06"],3,Mountain["microperc_07"],1).tick(:s)
end