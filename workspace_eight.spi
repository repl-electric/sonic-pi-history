def note_range_demo(low_note, high_note, options={})
  low_note = Note.resolve_midi_note(low_note)
  high_note = Note.resolve_midi_note(high_note)

  potential_note_range = Range.new(low_note, high_note)

  if options[:pitches]
    pitch_classes = options[:pitches].map {|x| Note.resolve_note_name(x) }

    note_pool = potential_note_range.select {|n|
      pitch_classes.include? Note.resolve_note_name(n)
    }
  else
    note_pool = potential_note_range
  end

  (ring *note_pool)
end


live_loop :bar do
  use_synth :fm

  with_random_seed 1 do
    root = knit(:c, 32, :f, 16, :c, 16, :g, 16, :f, 16, :c, 32).tick(:root)
    notes = note_range_demo(:c4, :c6, pitches: scale(root, :minor_pentatonic)).take(8).shuffle


    play notes.tick, release: 0.0
    sample :bd_ada, amp: 2 if spread(2,8).tick(:bd)
  end

  with_fx :echo, mix: 0.3 do
    with_fx :slicer, phase: 0.125, probability: 1.0 do
      sample :drum_cymbal_closed if spread(7,32).tick(:sn)
    end
  end
  sleep 0.125
end