D4=:d4;E4=:e4;FS4=:Fs4;GS4=:Gs4;Cs4=:Cs4;A4=:A4;B4=:B4;D3=:d3;E3=:e3;FS3=:Fs3;GS3=:Gs3;Cs3=:Cs3;A3=:A3;B3=:B3;D2=:d2;E2=:e2;FS2=:Fs2;GS2=:Gs2;Cs2=:Cs2;A2=:A2;B2=:B2;C2=:c2;C3=:c3 #__nonsave__
load "/Users/josephwilk/Workspace/repl-electric/do_ob/2018/jan/support/sample_map.rb";use_bpm 63.5;#set_volume! 1.0
sop_cc motion: 0.1
#sop_mode 0
REST=[[[_, 0.25]], 2]
live_loop :Fall_into_your_screen, sync: :unsyncable do
  tick
  #stop
  score =  (ing  #d f a
    [[[:b3   2] [:d4 2]  [:fs4 2]] 2] REST
    [[[:fs3  2] [:a4 2]  [:cs4 2]] 2] REST
    #[[[:a4   2] [:e4 2]  [:fs4 2]] 2] REST
    #REST  REST


    )
  s=score.look
  c=s[0]
  #eek :a2,   sus: 12, mode: 2
  #eek :cs3,  sus: 12, mode: 2
  if spread(1,6).look
    #rev :b5, 1
    #eek :Gs3, 10
  end
  #with_transpose 0 { piano3 root(c),(ing 127 120).look, sus: 2 }
  #rev :a6, 15, sus: 12
  piano root(c), (ring 35,40).look*1.5, sus: c[0][-1]
  c.each{|n|tick(:inner);
    sop n[0], 2.0*(ing 80 70 85 70).look(:inner), sus: ((n[-1])*1)+0.5, mode: 0, cutoff: (ramp 0.0, 0.1, 12).tick(:innert), cutoff: 1.0
    #piano3 n[0]
  }
  violin root(c), 127*1.0, mode: 1#, sus: 1.0, defon: 0.0, at: 1.0
  strings c[0][-2], 35
  #sleep (s[-1])*1
  broken root(c)+12*0, 10, motion: 0.1, mode: 0#, sus: 4.0, mode: 0
  yes{
    if spread(1,3).look
      with_fx :gverb, room: 200.0, mix: 0.8, release: 8, spread: 0.9 do
        with_fx :slicer, phase: 1/8.0 do
          smp Drip[/effect/].look, amp: 0.4, cutoff: 100, rate: -0.125, attack: 0.5
        end
      end
    end
  }
  sleep (s[-1])*1
end
    def zero_off(n,*args)
      midi_note_off n, port: :iac_bus_1, channel: 9
    end

#zero_on :fs5#,  channel: 9
zero_cc  pulse: .0, more: .0, noise: .4, wet: .7

#yes { vioshot(:a5, :on) }
#yes { vioshot_x }
#midi_note_on :a1, channel: 5

live_loop :By_the_light_of_the_terminal, sync: :unsyncable do
  with_fx :echo, mix: 1*(ring 0.025+rand*0.1,0.055+rand*0.1,0.03,0.02,0.01).look, phase: (ring 1/4.0, 1/8.0).look do
    8.times{
      #with_swing 0.01,2 do
        tick
        pp = (ing
          _ _ _ _    _ _ _ _     _ _ _ _    _ _ _ _
          _ _ _ _    _ _ D1 _    _ _ _ _   _ _ _ _
          ).look
        #pp=_
        if pp
          tick(:pp)
          fx = :none
          cutoff_bump=(pp.is_a?(Array) ? 15 : rand_i(10))
          accent = (pp.is_a?(Array) ? 0.7 : 0.4)*1
          if pp && pp.is_a?(Hash)
            fx = pp.values[0]
            pp = pp.keys[0]
          end
          with_fx(fx, phase: 1/3.0, decay: 1.5, room: 250, spread: 0.8, damp: 0.5,pre_damp:0.5,release:6){
            fuzz = rand(0.05)
            with_fx (ing :slicer,:echo).tick(:pfx), mix: 0.5, phase: 1/4.0, decay: 2 {
              smp pp, amp: accent+3.0, attack: 0.0, start: 0.1-fuzz, rate: (knit -0.25,32,-0.25,32,
                -0.5-fuzz, 1,-0.5,31,
                -0.25-fuzz,1,-0.25,31).look
            }
            smp pp, amp: (3+accent+(rand*0.1))*1,
            rate: -2*(knit 1.1,4, 1.0,2).look, pan: (ing
              0.25 0.25 -0.25 -0.25  0.25 -0.25
              0.5  0.5  -0.25 -0.25  0.25 -0.5
              0.5  0.5  -0.25 -0.25  0.25 -0.5
              ).look, cutoff: (ing 110,80).look+cutoff_bump, cutoff: (ramp 40,127,256*4).tick(:aaashoo2t)
          }
        end
      #end
      t=(ing
        _ _ _ _     _ _ 3 _    _ _ _ _   3 _ _ _
        _ _ _ _     3 _ _ _    _ _ _ _   _ _ _ _
        _ _ _ _     _ _ 3 _    _ _ _ _   3 _ _ _
        _ _ _ _     3 _ _ _    _ _ 3 _   3 _ _ _
        )
      s1 = (ing
        _ 5   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   5 _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ 5   _ _   [5] _   _ _   5 _  _ _  5 _  _ _
       )
      s2 = (ing
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   5 _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _   _ _  _ _  5 _  _ _
        )
      s3 = (ing
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        _ _   _ _   [5] _   _ _  5  _  _ _  5 _  _ _
        )
      s=(knit s2,16*4,s3,16*4, s1,16*4).look
      s=_
      t=_
      mt s.look,  accent=(line 90, 100, 16*4).look, 120
      mt t.look, accent=70,110
      #mt_cc morph: ((line 0.0, 1.0,16*16)+(line 1.0, 0.0, 16*16)).look
      sleep 1/8.0
    }
  end
end

mt_cc morph: 0.0

live_loop :Within_the_letters, sync: :light_source do;z,zs=nil;tick
  with_bpm 63.5 do #63.5
  live_loop :Fall_into_your_screen {stop}
  #stop
  zs=(ing
    :d4 :cs4 _ :a3 _ :e4 _ :A4 :A4 :A4 :A4 :A4
    :d4 :cs4 _ :a3 _ :b3 _ :A4 :A4 :A4 :Fs4 :A4
    )
  z=zs.look
  #z=_
  if z
    harp z
    piano z, 10+(ing 70 65 55).look * 1.0, sus: 4/2.0
  end

  sleep 1/2.0
  yes{
    v=1
    c = chord(zs.look(offset: 1),ct(zs.look(offset: 1)))
    #with_transpose   0 { zero c[1], v+1, sus: 12*1} if spread(1,2).rot(1).look
    #with_transpose -12 { zero c[2], v+2, sus: 12*1} if spread(1,2).rot(1).look
    #with_transpose  12 { zero c[0], v,   sus: 12*1} if spread(1,2).rot(0).look
    #with_transpose -24 { zero c[0], v,   sus: 12*1} if spread(1,2).rot(1).look
    #zero :fs5, 5, sus: 12*3 if z == :d4
    cue :zero if spread(1,2).rot(0).look
  }
  sleep 1/2.0
  #broken z-12, 10
  #eek z, sus: 6, mode:2 if spread(1,3).look
  no{
  if z == :d4
    64.times{|n|
      sleep 0.25/2.0
      broken :e5, 10, sus: 0.125 if n % 8 == 0
      sleep 0.25/2.0
      zero_cc noise: (line 0.0, 1.0,31).tick
      broken (ing :e4 :e4 :e4 :e4).tick(:n), (ing 2 4 6 8).look(:n), sus: 4, mode: 0 if n % 16 == 0
    }
    stop
  end
  }
        sleep 1/4.0
      end
end

#zero_cc  pulse: .5, more: .8, noise: .0

live_loop :Drip do
  sync :zero
  16.times{
    tick
    i=(ing 1.0 _ _ 0.5 _ _ 0.25 _ 1.0  _ _   0.5 _ _ 0.125 _).look
    if i
      smp Tape[/_high/,49], amp: i, pan: (ing -0.125 0.125).look, finish: (ine 0.2 1.0 100).look, start: (ine 0.0 0.8 100).look
    end
    sleep 1/8.0
  }
end

live_loop :Thump, sync: :unsyncable do
  8.times{
    tick
    DC = Drip[/cymbal/].look; CS = (0..17).map{|n| Crystal[/cymbal/].tick(:i)};
    C1 = (knit Analog[/clapraw/].look,8,Analog[/clap1/].look,8,Analog[/clap2/].look,8,Analog[/clap3/].look,16).look

    #smp TC.take(12).look, amp: 0.5+rand*0.1, rate: (ing 0.85,1.0, 1.0).look if spread(1,12*2).look
    #24

    k=(ing
      [KT[1]] _ _ _  TS[8] _ _ _      K1 _ _ _   _ _ _ _
      K1 _ _ _       _ _ _ _          K3 _ _ _   _ _ _ T1
      K1 _ _ _       %l{TC[6]} _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _       _ _ _ _          K1 _ %l{TC[6]} _   _ _ [F1 0.99] _
      K1 _ _ _       TS[8] _ _ _      K1 _ _ _   _ _ _ _
      K1 _ _ _       _ _ _ _          K3 _ _ _   _ _ _ T1
      K1 _ _ _       %l{TC[6]} _ _ _  K3 _ _ _   _ _ _ T1
      K1 _ _ _       _ _ _ _          K1 _ %e{TC[6]} _   _ _ [F1 0.99] _
      )

    #smp c2 if spread(1,16).look
    #k=k.map{|s| look % 32 == 0 ? _ : _ }
    #sop2_mode (ing 0 1 2 3 4 5 6).look#, motion: (ing 0.0,1.0).look
    #sop_mode(0) if !k

    kz=(ing
      [KT[1]] _ _ _   TS[2] _ TS[9] _     K3 _ TT[9] _  TS[3] _ _ _
      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     [K3] _ _ _   TS[3] _ _ _

      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     [K3] _ _ _   TS[3] _ _ _
      KT[1] _ _ _     TS[2] _ TS[9] _     K3 _ TT[9] _  TS[3] _ _ _

      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     K3 _ _ _   %h{TS[3]} _ _ T1
      K1  _ _ _       TS[2] _ TS[9] _     [K3] _ _ _   TS[3] _ _   _
      K1  _ _ _       TS[2] _ TS[9] _     K3 _ TS[15] _   %e{TC[6]} _ _ _
      )

    kz=(ing
      [KT[1]] _ _ K1    _ _ _ T1  _ _ _ _   K1 _ K1 _
      K1 _ _   K1    _ _ _ T1  _ _ _ _   K1 _ K1 _
      K1 _ _   K1    _ _ _ T1  _ _ _ _   K1 _ K1 _
      K1 _ _ _       _ _ _ T1  _ _ _ _   K1 _ K1 _
      )

    no{
    with_swing 0.08{
      hs=(knit
          (ing [Tape[/hi/,26]] _  _ _   TC[17] _  _ _).look, 8*2,
          (ing Tape[/hi/,26] _ _ _      TC[17] _  _ _).look, 8*1,
          (ing TC[17] _  _  TC[9]       [Tape[/hi/,26]] Tape[/hi/,34]  _ _).look, 8*1
         ).look
      accent=0.4
      if hs && hs.is_a?(Array)
        hs = hs[0]
        accent+=0.1+rand(0.09)
      end
      smp hs, amp: accent * 1.5
      }
    }
    s=(ing
      2 _ _ _ 5 _ _ _     5 _ _ _      _ _ _ _
      5 _ _ _   _ _ _ _   5 _ [2] 3    _ [5] 5 5
      ).look
    accent=110
    s=_
    if s && s.is_a?(Array)
      #eek :gs5, 90, sus: 1/8.0, mode: 0
    end
    if spread(1,6).look
      #eek :e5, 50, sus: 1/8.0, mode: 0
      #eek_cc mode: 2
    end
    if s
      mt s, accent=110, 120
    end
    if (s=(ing
        [5] _   5 _
        5   _   5 _
        5   _   5 _
        5   [5] 5 _
          ).look)
      s=_
      mt s,accent=85, 120 if s
    end

    s=(ing
      C5 _ C5 _  C5 _ [C5] C5    C5 _ C5 _  C5 _ C5 _
      C5 _ C5 _  C5 _ C5 _       C5 _ C5 _  C5 _ [C5] _
      C5 _ _ _   C5 _ _ _         C5 _ _ _   _ _ _ _
      C5 _ C5 _  C5 _ _ _         C5 _ C5 _  C5 _ [C5] _
      ).look
    s=(ing
      _ _ C5 _   _ _ _ _         _ _ _ _   _ _ _ _
      _ _ C5 _   _ [C5] C5 _     _ _ _ _   _ _ _ _
      _ _ C5 _   _ _ _ _         _ _ _ _   _ [C5] C5 _
      ).look
    accent = 0.5
    if s.is_a?(Array)
      accent = 0.8
      s = s[0]
    end
    no{
    with_swing 0.02 {
      smp s, amp: accent*0.5+(ing
          0.5 0 0.125 0 0.5 0 0.8 0.5
          0.5 0 0.125 0 0.8 0 0.125 0
          0.125 0 0.125 0 0.8 0 0.125 0
          0.125 0 0.125 0 0.125 0 0.8 0).look,
        pan: 0.0125, cutoff: (line 100, 127,64).look, pan: Math.sin(vt*13)/1.5
      }
    }

    k2=(ing
      _ _ _ _                          _ _ _ _
      _ _ _ _                          _ _ _ _
      [TS[49]] _ _ TS[12]              _ _ _ _

      _ _ _ _                          _ _ _ _
      _ _ _ _                          _ _ _ _
      TS[7] _ _ _                      _ _ _ _

      _ _ _ _                         _ _ _ _
      _ _ _ _                          _ _ _ _
      TT[49] _ _ TS[12]                _ _ _ _

      _ _ _ _                          _ _ _ _
      _ _ _ _                          _ _ _ _
      TS[7] _ _ _                      _ _ _ _
      )

    kp=k2.look
    fx=:lpf
    accent = (ing 0.2 0.2 0.3 0.5).look
    attack = 0.0
    r = 1.0
    if kp && kp.is_a?(Array)
      kp = kp[0]
      accent=accent*1.5
    end
    no{
    with_swing(0.01) do
      with_fx(fx, phase: (ring 1/4.0,1/4.0,1/8.0).look){
        smp kp, amp: 8*accent, rate: r, attack: attack if kp
      }
    end
    }
    k=k.look
    #k=_
    no{
      if spread(1,64).rot(-64+(8*2)).look   #4*1/8
        rev :d5, 60
      end
      if k && spread(1,64).rot(0).look
        #smp K1, amp: 5
        #sync :Fall_Into_Your_Screen
        sop :fs4, sus: 4.0
        cue(:light_source)
        violin_x;strings_x;zero_x
        sync :kernel_panic
      end
    }

    if spread(1,128).rot(-12).look
      #mt 13, (line 100,127, 128).tick(:blah),127
    end

    #midi(:c3, 60+(rand_i 10), channel: 2) if k == [kt[1]] #|| k.look == k3 || k == [kt[1]]
    kick_machine k, accent: 1.1, amp: 3.0*accent*1.1*(knit 0.8,4, 0.6,4, 0.7,4, 0.6,4).look, v: 0.2
    sidechain if k && spread(1,4).look
    sleep 1/8.0
  }
end

live_loop :Its_all_just_text_in_a_file, sync: :unsyncable do
  c1,c2,c3,c4 = *Drip[/cymbal/,[0,2,3,4]];
  with_fx :level, amp: 0.5 do
    with_fx :reverb, mix: 0.4, room: 0.5, mix_slide: 0.5 do |r_fx|
      8.times{
        tick
        if spread(1,16).look
          accent = spread(1,32).look ? 30 : 20
          #eek (ring :A1, :E2).tick(:in), accent, sus: 1, at: rand(1.0), mod: rand(1.0), mode: 2
        end

        ffx =(ing :hpf).look
        pp=(ing
          [c1] _ _ _   _ _ c1 _
          _ _ c1 _
          _ _ _ _      _ _ {c1=>ffx} _
          _ _ [c1] _
          ).look

        pxp=(ing
          [c1] _
          c1 _ _ _
          _ c1 _ _
          _ _ c1 _
          _ _ _ c1
          _ _ c1
          _ _ c1
          ).look
        pp=_
        if pp
          accent = pp.is_a?(Array) ? 1.0 : 0.8
          cutoff_bump = rand_i(5)
          fx = :none
          if pp && pp.is_a?(Hash)
            fx = pp.values[0]
            pp = pp.keys[0]
          end
          with_fx(fx){
            smp pp, cutoff: (line 110, 115, 6*4).look, attack: (line 0.02, 0.0,6*2).look, amp: accent*(line 1.0,0.9,6*8).look+10, start: 0.5, rate: -0.25*(knit 1,(6*4)-4, 0.85,4, 1,(6*4)-4, 0.75,4).look, pan: (ing 0.25 0.25 -0.25 0.25).look, cutoff: 110-cutoff_bump#, cutoff: (ramp 40, 120,256*3).tick(:fireandice)
          }
          if spread(1,6).look
            #smp MagicDust[:clack, [0,2,3,6]].tick(:insider), amp: 0.5*1, pan: (ring 0.25,-0.25).look(:inside)
          end
          if spread(3,7).look
            #smp Junk[/RedShaker/,18..22].tick(:i), amp: 0.2, pan: (ing 0.25,-0.25).tick(:ingit)
          end
        end

        sleep 1/8.0
        control r_fx, mix: rand(0.5)
      }
    end
  end
end

live_loop :should_not_loop_and_no, sync: :unsyncable do
  tick
  #C1 = CineElec[/one shots/,/pepper/]
  C1 = Tape[/_high/,49]
  s = spread(1,128).rot(-8*8 + 1).look
  if s
    #smp Words[/beaut/], start: 0.1, finish: 0.8, rate: 1.0, amp: 1.0
    with_fx (knit :none, 3*128, :echo, 128).look do
      smp C1, amp: 0.5, rate: (knit 1,2, 0.85,2, 1,2, 0.75,2).tick(:active)
    end
  end
  sleep 1/16.0
end

live_loop(:unsyncable) do; sleep 1.0 end
