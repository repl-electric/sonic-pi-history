#cam3
#viz breath: 0.0
#viz shard: 1.0
alive rotate: 0.01
cue :hit
live_loop :playing_piano_through_a_keyhole, sync: :hit do;tick
  dcam3
  with_bpm 64.5 do #63.5
    score=(ing
      D4 Cs4 _ A3 _ E4 _ A4 A4 A4 A4 A4
      )
    note=score.look
    future_note=score.look(offset: 1)
    operator note
    callstack note,(ing 70 65 60).look, sus: 2

    dviz shard: 0.7
    alive rotate: 0.09*rand


    sleep 1/2.0
    sleep 1/2.0
    sleep 1/4.0
  end
end



stop
camend
viz breath: 1.0
viz shard: 1.0
alive rotate: 1.0
128.times{
  electric
  sleep 2.0
  viz :alive, spike: 1.0
  alive color: (rand+0.2*0.8)*-1.0
}


stop
#camlogo logo: 1.0, crazy: 1.0, off: 1.0

#bitsea_on :CS4

#invcol
bitsea_cc motion: 0.10  #╟▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
bitsea_cc octave: 0.50  #╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
#bitsea_cc formant: 0.00 #╟▒░╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╢
#electri

#c
cue :hit


no{
qbitsea_cc oct: 0.00
qbitsea_cc drive: 0.30
qbitsea_cc charge: 0.50
qbitsea_cc fm: 0.40
qbitsea_cc wav: 0.72
qbitsea_cc wav_amp: 1.00
qbitsea_cc atk: 0.00
qbitsea_cc mod: 0.80
qbitsea_cc motion: 0.24
qbitsea_cc formant: 0.00
qbitsea_cc mul: 0.00
qbitsea_cc bass: 1.00
}

eq lo: 0.00
eq hi: 0.00




live_loop :pi, sync: :hit do;tick
stop
  #zero_x
  #dcam3 true
  with_bpm 63.5 do #63.5
    score=(ing
      :d4 :Cs4 _ :A3 _ E4 _ A4 A4 A4 A4 A4
      :d4 :Cs4 _ :A3 _ B3 _ A4 A4 A4 Fs4 A4)
    note=score.look
    future_note=score.look(offset: 1)
    operator note
    callstack note,(ing 70 65 60).look, sus: 2

    sleep 1/2.0

    chd = find_chord(future_note)
    if spread(1,2).rot(1).look
      with_transpose 0 {  zero chd[1],1,  sus: 12 }
      with_transpose -12 { zero chd[2],1, sus: 12 }
      with_transpose -24 { zero chd[0],1, sus: 12 }
    else
      with_transpose 0 {  zero chd[1],1,  sus: 12 }
    end

    sleep 1/2.0
    eek note, mode:2, sus: 6 if spread(1,3).look

    64.times{|n|
      sleep 0.125
      corrupt :e5, 10, sus: 0.125 if n % 8 == 0
      sleep 0.125
      corrupt (ing :e4 :e4 :e4 :e4).tick(:n), (ing 2 4 6 8).look(:n), sus: 4, mode: 0 if n % 16 == 0
    }
    stop


    sleep 1/4.0
  end
end

#zero_on :fs4
zero_cc pulse: 0.00
zero_cc more:  0.00
zero_cc noise: 0.20
zero_cc wet:   1.00
#zero_cc amp: 0.60

live_loop :fall_into_your_screen, sync: :unsyncable do;tick
#  stop
  dcam4
  score=(ing
    [:b2  :d3 :fs3]        Zz
#    [:fs2 :a4 :cs4]       Zz
#    [:a2  :b4  :e4]
    [:d2  :fs3 :a3 :e4]   Zz
#    [:e2  :gs3 :b3]    Zz
    [:a2  :cs3  :e3]       Zz

    ).look
  #callstack root(score), 70, sus: 0.125
  score.each_tick(:in){|n|
    qbitsea n, 1.0*(ing 80 70 85 70).look(:in), mode: 0, cutoff: 1.0, sus: 2.5, hi: 1.00, mi: 1.00, lo: 1.00
  }
  with_transpose -12 {cpu2 score[1], 60, sus: 2 }
  whitespace score[-1],1, sus: 12
  pf= 2.1
  electric
  i=(method :operator)
  alivecol 0.4
  at{
    i.call(score[0], 60*pf, sus: 4)
    sleep 0.5
    i.call(score[1], 50*pf, sus: 4)
        sleep 0.25

    i.call(score[2], 55*pf, sus: 4)
            sleep 0.25

    i.call(score[3], 70*pf, sus: 2)
            sleep 0.25

    i.call(score[4], 30*pf, sus: 8)
            sleep 0.25

    i.call(score[5], 30*pf, sus: 8)
            sleep 0.25

  }

  at{
  16.times{tick(:k)
    kick_machine k=(ing
      K1 _ _ _   _ _ _ _  K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ _ _   _ _ _ _
        ).map{|c| look(:k) % 64 == 0 ? c : _}.look(:k), def: 8, accent: 2

    no{
      if k && spread(1,64).rot(0).look
        bitsea :fs4, sus: 4.0
      end
      }

    sleep 1/8.0
    }
    }


  exception root(score),30, atk: 0.05, more: 0.0, shape: 1.0, wet: 0.0, sus: 0.8
  sleep 1
  null root(score),100
  invcol 0.0
#  verb_slice Drip[/effect/].look if spread(1,3).look
  sleep 1
end

live_loop :by_the_light_of_the_terminal, sync: :unsyncable do
  stop
  with_fx :echo, mix: 1*(ring 0.025+rand*0.1,0.055+rand*0.1,0.03,0.02,0.01).look, phase: (ring 1/4.0, 1/8.0).look do
    8.times{
      tick
      pp=(ing
        _ _ _ _    _ _ _ _    _ _ _ _   _ _ _ _
        _ _ _ _    _ _ D1 _    _ _ _ _   _ _ _ _

        ).look
      smp_dust(pp, amp: 1.1)
      terrain 0.3 if pp
      mt mt_pat.look.look, accent=(line 75, 85, 16*4).look, 100
      mt_cc morph: ((line 0.0, 1.1,16*16*2)+(line 1.1, 0.0, 16*16*2)).look
      s=(ing
        2 _ _ _  5 _ _ _    5 _ _ _      _ _ _ _
        5 _ _ _   _ _ _ _   5 _ [2] 3    _ [5] 5 5
        ).look
      mt s, accent=(line 75, 85, 16*4).look, 100
      s=strpat("[5]p5p5p5p 5p5p5[5]5p")
      #mt s.look,accent=(line 85,127,64).look, 120


      sleep 1/8.0
    }
  end
end

live_loop :its_all_just_text_in_a_file, sync: :unsyncable do
  tick
stop
    kick_machine k=(ing
      [KT[1]] _ TS[8] _   _ _ _ _  K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ _ _   _ _ _ _
      K1      _ _ _   %l{TC[6]} _ _ _      K3 _ _ _   _ _ _ _
    K1      _ _ _   _ _ _ _      K3 _ %l{TC[6]} _   _ _ _ _

          K1 _ _ _   _ _ _ _  K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ _ _   _ _ _ _
      K1      _ _ _   %l{TC[6]} _ _ _      K3 _ _ _   _ _ _ _
      K1      _ _ _   _ _ _ _      K3 _ %e{TC[6]} _   _ _ _ _
      ).map{|c| look % 8 == 0 ? c : c}.look, def: 8, accent: 1

    yes{
      if k && spread(1,32).rot(0).look
        bitsea :fs4, sus: 4.0
        cue :hit
        stop
      end

    }

#  sleep 1/8.0

    p=(ing
      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      [TS[49]] _ _ TS[12]    _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TT[49] _ _ TS[12]      _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _
      )

    p=p.look
    #p=_
    fx=:lpf
    accent = (ing 0.2 0.2 0.3 0.5).look
    attack = 0.0
    r = 1.0
    if p && p.is_a?(Array)
      p = p[0]
      accent=accent*1.5
    end
    if p
      with_swing(0.01) do
        with_fx(fx, phase: (ring 1/4.0,1/4.0,1/8.0).look){
          at{
            sleep 0.5
            viz :sea, height: 0.3
            viz :sea, noise: 10.0
            sleep 0.125
            dviz :sea, height: 0
            viz :sea, noise: 0.01
          }
          smp p, amp: 3*accent, rate: r, attack: attack
        }
      end
    end

  sleep 1/8.0
end

live_loop(:unsyncable) do; sleep 1.0 end
