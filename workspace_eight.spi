def deg_seq(*pattern_and_roots)
  pattern_and_roots = pattern_and_roots.reduce([]){|accu, id|
    if(/^[\d_]+$/ =~ accu[-1] && /^[\d_]+$/ =~ id)
      accu[0..-2] << "#{accu[-1]}#{id}"
    else
      accu << id
  end}
  patterns = pattern_and_roots.select{|a| /^[\d_]+$/ =~ a.to_s }
  roots   = pattern_and_roots.select{|a| /^[\d_]+$/ !~ a.to_s}
  notes = patterns.each_with_index.map do |pattern, idx|
    root = roots[idx]
    if(root[0] == ":")
      root = root[1..-1]
    end
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
    if(s == :minor)
      s = if    root.to_s[1] == "h"
        :harmonic_minor
      elsif root.to_s[1] == "m"
        :melodic_minor
      else :minor
      end
    end
    root = root[0] + root[2..-1] if root.length > 2
    pattern.to_s.split("").map{|d| d == "_" ? nil : degree(d.to_i, root, s)}
  end.flat_map{|x| x}
  ring( *notes)
end


#play deg_seq(*%w{:a2 541})

#play chord_degree(5, :a2, :minor), release: 2
#sleep 2
#play chord_degree(4, :a2, :minor), release: 2
#sleep 2
#play chord_degree(3, :a2, :minor), release: 2
#sleep 2

#play chord_degree(1, :a2, :minor), release: 2
#sleep 2
#play chord_degree(6, :a2, :minor), release: 2
#sleep 2
#play chord_degree(5, :a2, :minor), release: 2

#165

  #  play_darkness deg_seq(*%w{:a2 13})[idx],bar
 #   idx+=1
#end;end
bar = 2

#play ring( chord_degree(1,:a2, s)[0..3],chord_degree(2,:a2, s)[0..3],chord_degree(3,:a2, s)[0..3],chord_degree(5,:a2, s)[0..3])[idx], release: 2

def play_darkness(n, bar)
  with_synth(:tri){play n,  amp: 0.2, attack: 0.0, release: bar, decay: bar, sustain: bar/2}
  with_fx(:pitch_shift, pitch_dis: 0.01){with_fx(:reverb, mix: 0.5){with_synth(:prophet){ play n, cutoff: 70, amp: 3.0,  attack: 0.0, release: bar*4}}}
end

live_loop :a do |idx|play_darkness deg_seq(*%w{:A2 1    6    6    4    4    4    6    6   })[idx],bar;sleep bar*2;idx+=1;end
live_loop :melody do |idx|    play deg_seq(*%w{:A3 3111 6111 5111 4111 3111 3111 3111 4112})[idx],amp: ring(1.2,0.9,1.1,0.9)[idx];sleep bar/4.0;idx+=1;end
#live_loop :beat do   |idx|   play deg_seq(*%w{:A2 5555 4444 1111 1111 5555 4444 7777 1111})[idx], attack:ring( 0.01,0.1,0.01,0.1)[idx];sleep bar/2.0;idx+=1;end
#live_loop :beat2 do  |idx|   play deg_seq(*%w{:A2 1111 6666 5555 5555 1111 6666 5555 7777})[idx];sleep bar/2.0;idx+=1;end
live_loop :beat3 do  |idx|    play deg_seq(*%w{:A1 1 _ _ _  _ _ _ _  _ _ _ _  _ _ _ _})[idx],release:2;sleep bar/4.0;idx+=1;end


live_loop :d do |i|
sync :a
n= (ring *SonicPi::Chord::CHORD.keys)[i]
puts n
play chord(:a3, n), amp: 5, release: 4
i+=1


end



#play deg_seq(*%w{:a2 541})
#play deg_seq(*%w{:a2 165})