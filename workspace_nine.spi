x =(knit :As4, 4, :B4, 4,  :Cs4, 4, :B4, 4)
#              3           4          -              

#puts %w{F#4 34  F#3 5 F#4 4}*8
#puts %w{A#4 B4 C#4 B4*4}

#               1   2  3  4 5  6   7  8
#Cs Ds Es Fs Gs As B Cs Ds Es Fs
#puts x

def deg_seq(*pattern_and_roots)
  pattern_and_roots = pattern_and_roots.reduce([]){|accu, id|
    if(/^[\d_]+$/ =~ accu[-1] && /^[\d_]+$/ =~ id)
      accu[0..-2] << "#{accu[-1]}#{id}"
    else
      accu << id
  end}
  patterns = pattern_and_roots.select{|a| /^[\d_]+$/ =~ a.to_s }
  roots   = pattern_and_roots.select{|a| /^[\d_]+$/ !~ a.to_s}
  notes = patterns.each_with_index.map do |pattern, idx|
    root = roots[idx]
    if(root[0] == ":")
      root = root[1..-1]
    end
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
puts s
    if(s == :minor)
      s = if    root.to_s[1] == "h"
        :harmonic_minor
      elsif root.to_s[1] == "m"
        :melodic_minor
      else :minor
      end
    end
    #MESSEY 
    root = root[0..1] + root[2..-1] if root.length > 2
    pattern.to_s.split("").map{|d| d == "_" ? nil : degree(d.to_i, root, s)}
  end.flat_map{|x| x}
  (ring *notes)
end


def note_seq(*patterns)
  patterns.reject{|a| a.empty?}.
  map{|a|
    note, factor = a.last.split("*")
    factor ||= "1"
    factor = factor.to_i
    a[-1] = note
    a.map{|s| s.gsub(/#/,"s")}.
                     map{|s| [s.to_sym] * factor }.
                     flatten
                     }.
  flatten.ring
  end

x =(knit :As4, 4, :B4, 4,  :Cs4, 4, :B4, 4)
#              3           4          -              

#puts %w{F#4 34  F#3 5 F#4 4}*8
#puts %w{A#4 B4 C#4 B4*4}

puts "-----------"
puts x.map{|s| note_info(s).midi_note}
puts "-----------"
puts deg_seq(*%w{Fs4 34 Fs3 5 Fs4 4}).map{|a| [a]  * 4}.flatten
puts  stretch(deg_seq(*%w{Fs4 3 4 Fs3 5 Fs4 4}), 4)
puts  note_seq(%w{A#4 B4 C#4 B4*4},  %w{}).map{|s| note_info(s).midi_note}

class SonicPi::Core::RingVector
  include SonicPi::SpiderApi
  def stretchy(n)
     res = self.to_a.each_slice(2).flat_map do |values, num_its|
        if !values.respond_to? :flat_map
          values = [values]
        end
        knit(*values.flat_map{|v| [v, num_its]})
      end
      (res||[]).ring
  end
end

puts deg_seq(*%w{Fs4 34 Fs3 5 Fs4 4}).stretchy(4)