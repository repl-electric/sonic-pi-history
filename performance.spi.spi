load_support('analog_in_the_digital'); use_bpm 127/2.0
#init!
#vox_cc sync: 0
#glitch_cc mode: 2

live_loop :form, sync: :unsyncable do
  tick
  score = (ing
    #P1
    # [:e3   :g4  :b3     :fs3]
    # [:e3   :g4  :b3      _]
    # [:e3   :g4  :b3     :fs3]


    # [:d3   :fs4  _      :a3]
    # [:g3   :b4   _      :d3]
    # [:a3   :c4   _      :e4]
    # [:a3   :c4   _      :e4]

    # [:a3   :c3   :fs4   :e4]
    # [:d3   :fs4  [:E4].choose :cs5]

    #P2
    [:e3    :g3    :a3   :fs3]
    [:fs3   :g3    :b3    :a3]
    [:c3    :e3    :a2   :e3]


    # [:e3     _     :c4   :g3]
    # [:e3     _     :d4   :fs3]

    # [:e3     _     :c4   :g3]
    # [:e3     _     :e4   :fs3]

    # [:d3   :fs3    :a2   :e3]
    # [:d3   :fs3    :b2   :g3]

    # [:g3   :b3    :c4   :d3]

    # [:fs3  :a3   :c4   :d3]
    # [:fs3  :a3   _     :e3]

    # [:g3  :b3    :g4   :g3]
    # [:g3  :b3    :a4   :g3]

    ).look
  puts score

  #voxe_cc semitone: 5
  no{
    d=[8,6].shuffle
    glitch_cc ldelay: d[0], cdelay: (knit 2,4,3,4).look, rdelay: d[1], wash: 0.25*(ing 1.0 0.0 1.0 0.0).look
    glitch :C3, 85*1
    at{
      dice(32) > 15 ? sleep(4) : sleep(3)
      glitch_cc wash: 0.0
    }
  }

  s = spread(3,4).look
  w=(line 1, 0.5, 32).look
  at{
      #bass octave(score[1] || score[2] , 3), 120, sus: 2.5*2, wet: 1
      #bass score[0], 120, sus: 2.5*2#, wet: 0.0, more: 0.5, shape: 0.8
      #midi :e3, channel: 4, sustain: 4, sus: 2
      sleep 1.0/2.0
      #sop_cc mode: 0
      #sop :b3, sus: 0.5
      sleep 2
      sleep 1.0/2.0
      #looper score[1],60
      #midi :g5,127, channel: 4, sustain: 4, sus: 2
      #bass root(score)-5,115, sus: 0.5 if s
      sleep 0.25
      #sop_cc mode: (ing 0 0 1  0 0 2  0 0 3  0 0 4  4 4 5).look
      #with_swing((line 0, -0.05, 32).look){
      #  sop score[0], sus: 0.5
      #}
      sleep 0.25
      #at{
      #  sleep 0.25
      #  2.times{
      #    sop_cc mode: 1
      #    sleep 0.5
      #    sop score[0]+12,(ing 60 70).tick(:ititit), sus: (ing 1.0 4.0).tick(:ssss)
      #  }
      #}
      #bass octave(score[-1],3),105, sus: 0.5, wet: w
  }

  #vox_cc semitone: 5
  #glitch_cc kick: true
  if true
    #vox_cc sync: 0, wet: 0

    vox  score[0],  sus: 1.5
    if (ing 1 0).look == 0
      #vox   score[0],  sus: 1.5
    else
      #vox2  score[0],  sus: 1.5
    end
    looper score[0],  sus: 1.5, pat: (ing 1/2.0 '1/2d').look#, elec: false, cutoff: (ramp 0.9, 1.0,256).tick(:hitit), abite: 0.0, bbite:  0.0, atk: 0.6, reverb: 1.0, creverb: 1.0
    with_transpose 12{
      piano score[1],62,sus:2
    }
    sleep 1/2.0
    sleep 1/2.0

    piano score[1], 60, sus:2  if spread(1,2).look
    with_transpose 12{
      piano score[1], 62, sus:2
    }

    #vox  score[3], 82,  sus: 2.5     # 3
    if (ing 1 0).look == 0
      #vox   score[3], 80,  sus: 2.5     # 3
    else
      #vox2  score[3], 80,  sus: 2.5    # 3
    end
    looper score[3], 80,  sus: 2.5, pat: 1/8.0         #0

    sleep 1/2.0
    piano score[0], 60, sus:2  if spread(1,3).rot(-1).look
    #glitch :f3, 60
    sleep 1/2.0

    #glitch :as3,50
    sleep 1/2.0

    #glitch :e3, 60+rand*5 if spread(1,2).look

    sleep 1/2.0

    with_transpose 12{
      #sop score[-1], 40, sus: 0.25 if spread(7,11).rot(-1).look    #2
    }

    #with_swing 0.05{ glitch :d3, 60+rand*5 if spread(1,2).rot(-1).look }

    sleep 1/2.0

    sop_cc mode: (ing 0 6  0 8).look
    sop score[2], (ing 5 10).look, sus: 4.0    #2

    #glitch :fs3, 60+rand*5 if spread(2,3).look
    sleep 1/4.0
    #with_swing -0.05{ glitch :fs3, 70+rand*5  if spread(4,5).look }
    piano score[0]-5, 60, sus:2  if spread(1,3).rot(-2).look
    sleep 1/4.0
  elsif true
    sop_cc mode: (ing 0 4 0 3).look

    fx wash: 0.0
    vox  :fs3,   sus: 1.5
    vox_cc sync: 0, wet: 0.5, detune: 0.5, semitone: 5
    #vox_cc
    piano score[2],82, sus:2.5
    sleep 1/2.0

    at{
      sleep 0.5
      piano score[1], 62, sus:0.25
    }
    with_transpose 12{
      piano score[0],82, sus:1
    }

    glitch :a3,40
    sleep 1/4.0
    piano score[1],60, sus:1
    sleep 1/4.0
    vox  :b3, 45,  sus: 2.5
    vox  :d4, 50,  sus: 1.5

    piano :d5, 72, sus:1
    sleep 1/2.0
    glitch :fs3,30 if spread(1,2).look
    sleep 1/4.0
    piano score[-1]+12,82, sus:1
    #glitch :a3,45

    sleep 1/4.0
    sop :fs4, 40
    sleep 1

    with_transpose 12{
      piano score[1], 85, sus:0.25
    }

    #looper score[-2]+5, 80
    glitch :b4, 50
    sleep 0.5
    with_transpose 12{
      sop score[1], 85, sus:0.25
    }
    sleep 0.5
  end
end

live_loop :name, sync: :unsyncable do
  tick
  N = 1; H = 1/2.0; Q = 1/4.0; E = 1/8.0; S = 1/16.0
  score = (ing
    [:G3 Q]   [_ Q]
    [:A2 E]   [_ E]
    [:B2 E]   [_ E]
    [:A2 E]   [_ E+Q]

    [:B3 Q]   [_ Q]
    [:D3 E]   [_ E+Q]
    [:D3 Q] [_ Q]
    [[:D3 :G3 :E3].choose N [2,1].choose]
    )
  note = score.look
  yes{
    if note[0]
      #with_swing((line 0, -0.04, 8).look(:note)){
      #  with_transpose 12{
          #vox note[0],127, sus: note[-1]
      #  }
        #midi note[0], 0.65*(ing 100 127 50 60  85 95 110 120).tick(:note),  sus: note[-1],  channel: 1
      #}
    end
  }
  sleep note[1]
end

live_loop(:unsyncable) do; sleep 1.0;end
