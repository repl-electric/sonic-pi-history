# Welcome to Sonic Pi v2.11

require "mysql2"
module Dsp
  def self.query(sql)
    SonicPi::Core::RingVector.new(Dsp.connection.query(sql,:symbolize_keys => true).to_a)
  end
  def self.connection()
    @@connection ||= Mysql2::Client.new(:host => "localhost", :username => "root", :database => "repl_electric_samples", :reconnect => true)
  end
  def self.connect!()
    @@connection = Mysql2::Client.new(:host => "localhost", :username => "root", :database => "repl_electric_samples",:reconnect => true)
  end
end

module Samples
  def self.sql(query="")
    Dsp.query("select * from samples where #{query}")
  end
  def self.find(path: nil, note: nil, max: nil, min: nil)
    @@cache ||= {}
    k = "samples[note#{note}path#{path}max#{max}min#{min}]"
    if !@@cache.has_key?(k)
      query = []
      query << "path like '%#{path}%'" if name
      query << "note1='#{note}'" if note
      query << "length < #{min}" if min
      query << "length > #{max}" if max
      r = Dsp.query("select * from samples where #{query.join(" AND ")}")
      @@cache[k] = r
    end
    @@cache[k]
  end
  def self.flush
    @@cache = {}
  end
end

module SampleBeats
  def self.sql(query="")
    Dsp.query("select * from track where #{query}")
  end
  def self.find(path: nil, col: collection, filename: f)
    @@cache ||= {}
    k = "path[query]"
    if !@@cache.has_key?(k)
      query = []
      query << "path='#{path}'" if path
      query << "collection='#{path}'" if col
      query << "collection ='#{f}'" if f
      r = Dsp.query("select * from track where #{query.join(" AND ")} ORDER BY beat")
      puts "results#{r}"
      if r && !r.empty?
        beats = r.map{|r| r[:beat]}
        r = {beats: beats[1..-1]}.merge(r[0])
      end
      @@cache[k] = r
    end
    @@cache[k]
    r
  end
  def self.flush
    @@cache = {}
  end
end

module NoteSlices
  def self.sql(query="")
    Dsp.query("select * from notes_fine where #{query}")
  end
  def self.find(root: nil, octave: nil, min: nil, max: nil, note: nil, pat: nil)
    @@cache = {}
    octave = if !note.nil?
      note[-1]
    else
      octave
    end
    root = if !note.nil?
      note[0..-2]
    else
      root
    end
    k = "noteslices[note#{root}octave#{octave}max#{max}min#{min}]"
    if !@@cache.has_key?(k)
      query = []
      query << "note='#{root}'" if root
      query << "octave=#{octave}" if octave
      query << "length > #{min}" if min
      query << "length < #{max}" if max
      query << "path REGEXP '#{pat}'" if pat
      query = query.flatten
      r = Dsp.query("select * from notes_fine128 where #{query.join(" AND ")}")
      @@cache[k] = r
    end
    @@cache[k]
  end
  def self.flush
    @@cache = {}
  end
end

_=nil
def note_slices(note, m)
  NoteSlices.find(note: note, max: m, pat: "sop|alto|bass").select{|s| s[:path] =~ /sop|alto/}.take(32)
end
@slices ||= {"Gs2/4" => note_slices("Gs2",1/4.0),"D2/4" => note_slices("D2",1/4.0), "E2/4" => note_slices("E2",1/4.0), "A2/4" => note_slices("A2",1/4.0), "Fs2/4" => note_slices("F#2",1/4.0),"Fs2/8" => note_slices("F#2",1/8.0), "E3/4" => note_slices("E3",1/4.0), "D3/4" => note_slices("D3",1/4.0),"D3/8" => note_slices("D3",1/8.0),"Cs3/4" => note_slices("C#3",1/4.0), "Fs3/8" => note_slices("F#3",1/8.0),"Fs3/4" => note_slices("F#3",1/4.0), "Gs3/4" => note_slices("G#3",1/4.0), "A3/8" => note_slices("A3",1/8.0),"A3/4" => note_slices("A3",1/4.0), "B3/4" => note_slices("B3",1/4.0), "Cs4/4" => note_slices("C#4",1/4.0), "Cs4/8" => note_slices("C#4",1/8.0), "D4/4" => note_slices("D4",1/4.0),"D4/8" => note_slices("D4",1/8.0), "E4/4" => note_slices("E4",1/4.0),"E4/8" => note_slices("E4",1/8.0), "Fs4/4" => note_slices("F#4",1/4.0),"Fs4/8" => note_slices("F#4",1/8.0), "Gs4/4" => note_slices("G#4",1/4.0), "B4/4" => note_slices("B4",1/4.0),"Fs5/4" => note_slices("F#5",1/4.0), "Fs6/4" => note_slices("F#6",1/4.0),"A4/4" => note_slices("A4",1/4.0),"E5/4" => note_slices("E5",1/4.0)}
#@slices.values.flatten.each{|f| load_sample f[:path]}

#puts @slices.values.flatten.count

with_fx :reverb, room: 0.4 do
  live_loop :doit do
    tick
    with_fx :lpf, cutoff: (line 120, 135, steps: 64).look, mix: 0 do
      with_fx :bitcrusher, bits: (line 10, 32, steps:1).look, mix: 0, sample_rate: 6000 do
        smp Dust[/LI_/,6..8].look
        smp (knit
             @slices["Fs4/4"].look, 16,
             @slices["D4/8"].look, 1,
             @slices["E4/4"].look,1
             ).look, amp: 1, pan: (ring 0.25, 0.25, -0.25, -0.25).look
        sleep 1/4.0
      end
    end
  end
end

live_loop :drums, sync: :doit do
  tick
  if (spread 1,4).look
    smp Mountain[/subkick/,2], amp: 1.2#, rpitch: :Fs0
    sleep 1/1.0/2.0
    smp Mountain[/subkick/,0], amp: 0.8#, rpitch: :Fs0
    sleep 1/1.0/2.0
    smp Mountain[/pebble/,1], amp: 0.5#, rpitch: :Fs0
    sleep 1/1.0/2.0
    sleep 1/1.0/2.0
  else
    smp Mountain[/subkick/,0], amp: 2.1#, rpitch: :Fs0
    sleep 1/1.0
    smp Mountain[/subkick/,0], amp: 2.1#, rpitch: :Fs0
    smp Mountain[/snare/,1], amp: 0.2#, rpitch: :Fs0
    sleep 1/1.0
  end
end

live_loop :skitters, sync: :doit do
  tick
  if spread(3,8).look
    smp @slices["Fs3/8"].look, amp: 4
    smp Frag[/hat/,[1,2]].look, amp: 0.05, rpitch: (ring 12, 24, 12).look
  end
  if spread(7,11).look
    smp Frag[/hat/,[0,1]].look, amp: 0.05, rpitch: (ring 0, 12, 12).look
  end
  sleep 0.25
end

live_loop :synths, sync: :doit do
  tick
  s = (knit
       (chord :Fs3, :m),2,
       (chord :D3, :M),2,
       (chord :D3, :add9),2,
       (chord :E3, :sus4),1,
       (chord :E3, :M),1,
       #(chord :Cs3, :m),4)
       )
  puts note_inspect(s.look)
  synth :gpa, note: s.look, decay: (ring 1.6).look, amp: 5, attack: (ring 0.0, 0.1).look
  with_transpose -12*2 do
    bass = (knit
            (chord :FS3, :m)[0],1,
            (chord :FS3, :m)[1],1,
            (chord :D3, :M)[0],2,
            (chord :D3, :add9)[0],2,
            (chord :E3, :sus4)[1],1,
            (chord :E3, :M)[0],1,
            (chord :Cs3, :m)[2],1,
            (chord :Cs3, :m)[1],1,
            (chord :Cs3, :m)[0],2
            )
    synth :dsaw, note: bass.look, cutoff: 50, decay: 1, amp: 1.5, attack: 0.2
    synth :dark_sea_horn, note: s.look[0], cutoff: 100, decay: 1, amp: 1.5
  end
  synth :dark_sea_horn, note: s.look[1], cutoff: 80, decay: 1, amp: 0.5
  sleep 2
end

live_loop :perc do
  tick
  synth :plucked, note: (ring
                         _, :Fs3, _,_,
                         _, _,:b3,:a3,
                         _, :Fs3, _,_,
                         _, _,:b3,:a3,
                         _, :Fs3, _,_,
                         _, _,:b3,:a3,
                         _, :Fs3, _,_,
                         _, _,:cs4,:a3,
                         ).look, decay: (ring 0.25,0.5).look, amp: 0.7, attack: 0.05
  sleep 0.125
end
