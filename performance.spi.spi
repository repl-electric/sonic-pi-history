load_support('piezoelectric_resonator'); use_bpm 127
#overclock_x
#defaultcolor
#explode_cube
#cam :top
#init! true
#world time: 1.0
#cube wires: 0
#cam :main
#stop


#roots throttle: 0.0
vortex throttle: 0
roots chase: 3.0, target: :cube, force: 2.0, radius: 0.01, drag: 1.0
stop

#create_light
#star size: 2, life: 5
#world time: 0.02
#roots chase: 0.08, target: :spiral, drag: 3.0, amp: 0.06
#roots chase: 0.0, throttle: 0

#rocks throttle: 0.0

#roots alive: 1.0
#create_bird -1.0

#explode_world

#star size: 12, life: 5

#explode_world
#create_tree -2
#create_aura -2
#rocks throttle: 0.0
#endit
#end1
#vortex throttle: 0.0
#rocks throttle: 0.0
#roots swirl: 1.0, drag: 4

#roots swirl: 1.0, drag: 4.0, amp: 0.1

#end2
#star size: 15
#rocks orbit: 100.0
#create_sea -10
#end1
#create_sea -1
#roots swirl: 1.0, drag: 0.0, amp: 0.1
#roots alive: 1.0, drag: 3.0
#end2

#stop

live_loop :go, sync: :unsyncable do
  tick
  if spread(3,8).look
    glitch :c3, (ing 120 90 100 100    100 90 90 90).look
    glitch_cc corode: 0.7
  end
  if spread(1,12).look
    glitch_cc mode: (ing 0 2 3 5).look
    #mt S, [100,80,90,70,100].choose, [100,80,90,70,100].choose
    glitch (ing :f3 :g3).look, 90
  end
  if spread(1,8).rot(0).look
    #glitch :e3, 127
    #mt 6, 30, 100
  end
  sleep 1/2.0
end

fx reverb: 1.0

#overclock_x
#solo :pad

#overclock_off :G2
#overclock_on :F2

#glitch_cc 5
#overclock_on :A3
#overclock_cc motion: 0.25, oct: 0
#overclock_on :G3

# E F A   E G B root

# E G B D F
# F A C E G
# A C E G B

#A B

#overclock_on :E3

solo :pad

fx reverb: 1.00
#mbox on: 0.0
#mbox2 on: 0.0

live_loop :ModularSynthsControlledByCode, sync: :unsyncable do; tick
  ratio = 1
  with_bpm 127*1 do
    kalshot :G3, [5,10,15,20].choose, sus: 6 if spread(1,12).look

    if spread(7,11).look
      mbox2 :D4, 2*(ing 50 60 70 110).look, sus: 1.0/2.0
      sleep 1/2.0
      mbox  :A3, 50, sus: 1.0
      sleep 1/2.0

    else
      mbox2 :C4, 2*(ing 50 60 70 110).look, sus: 1.0/2.0
      sleep 1/2.0
      mbox  :D3, 50, sus: 1.0
      sleep 1/2.0
    end

    glitch_cc corode: (ine 0.2 0.7 128).look
    glitch (ing :c3 :a3).look, 30 if spread(7,11).look

    with_swing -0.1 {
      mbox2 :E4, 5.5*(ing 50 60 70 110).look, sus: 1.0/2.0
    }
    sleep 1/2.0
    sleep 1/2.0
#    mbox :G3, 127, sus: 1.0/8.0 if spread(3,8).look
    with_swing -0.1 {
      mbox :f2, 127-rand*10, sus: 1.0/4.0
    }

    sleep 1
    sleep 1
  end
end

#keep
#mbox_cc motion: 0.30, drive: 1.00, sat: 1.00
#mbox2_cc sat: 1.00, motion: 0.50, drive: 0.00

#mbox_cc motion: 0.70, drive: 0.00, sat: 0.00
#mbox2_cc sat: 1.00, motion: 0.60, drive: 0.00

##mbox_cc motion: 0.30, drive: 1.00, sat: 1.00
#mbox2_cc sat: 1.00, motion: 0.30, drive: 0.65

#overclock_cc motion: 0.45, drive: 0.60


#world time: 1.0
# live_loop :wind, sync: :unsyncable do; tick
#   stop
#   if spread(1,128).rot(-2).look
#     mt S, 20, 20
#   end

#   s =(knit :A3, 128, _, 128).look
#   #qbitsea s, (line 127,50,256*4).look, sus: (knit 1/4.0,32,1/2.0,31, 1, 1).look if spread(7*1,11*4).look

#   if spread(7*1,11*4).look
#     if spread(7*1,11*4*8).look
#       #bitsea :A4, (line 127,100,256).look, sus: 2, hi: 0.85
#     end
#   end

#   # qbitsea :G3, ((line 20,40,128)+(line 40,20,128)).look, sus: (ing 1/4.0 1/2.0 1/4.0).look if spread(3*4,8*4).look
#   # qbitsea :E3, 50, sus: (ing 1/2.0 1 1).look if spread(1*4,8*4).look
#   sleep 1/8.0
# end
#zero_x

live_loop :light, sync: :unsyncable do; tick
  scorez = (ing   #64
    # [[:A3 :C5 :E4] 4]
    # [[:F4 :A6 :C5] 8]
    # [[:C3 :E5 :G4] 4]
    # [Zz 4]
    # [[:A3 :C5 :E4] 8]
    # [[:E4 :G5 :B3] 8]
    # [[:F4 :A5 :C5 :E5] 4]
    # [[:F4 :A5 :C5 :E5] 4]
    # [[:C3 :E5 :G4] 8]
    # [Zz            8]

    # [[:A3 :C5 :E4] 8]
    # [[:F4 :A6 :C5] 8]
    # [[:C3 :E5 :G4] 8]
    # #[Zz            4]
    # [[:A3 :C5 :E4] 8]
    # [[:E4 :G5 :B4] 8]
    # [[:G4 :C7 :D5] 8]
    # [[:G4 :B6 :D5] 4]
    # [[:C4 :E5 :G4] 8]
    # [Zz            8]

    [[:A3 :C5 :E4] 8]
    [[:F4 :A6 :C5] 8]
    [[:C3 :E5 :G4] 4]
    [Zz 4]
    # [[:A3 :C5 :E4] 8]
    # [[:E4 :G5 :B3] 8]
    # [[:F4 :A6 :C5 :E5] 8]
    # [[:C3 :E5 :G4] 8]
    # [Zz 8]

    # [[:A3 :C5 :E4] 8]
    # [[:F4 :A6 :C5] 8]
    # [[:C3 :E5 :G4] 4]
    # [Zz 4]
    # [[:A3 :C5 :E4] 4]
    # [[:A3 :C5 :E4] 4]
    # [[:E4 :G5 :B3] 4]
    # [[:E4 :G5 :B3] 4]
    # [[:G4 :B6 :D5 :F4] 8]
    # [[:C4 :E5 :G4] 8]
    # [Zz 8]


    # [[:G2 :B2 :D3] 8*2]      #  # 7thm
    # [Zz 2]
    # [[:G2 :B2 :D3 :F3] 8*2]  #   # 7thm
    # [Zz 2]
    # [[:G2 :B3 :D3 :F3] 8*2]  #   # 1 5 7 3  - 3 on top
    # [Zz 2]
    # [[:G2 :B3 :D3 :F4] 8*2]  #   # 1 5 3 7  - 7 on top
    # [Zz 2]
    # [[:G2 :B5 :D4 :F3] 8*2]  #   # 1 7 5 3  - shell
    # [Zz 2]


    # [[:C4 :E5 :G4] 8]
    # [Zz            8]

    )
  score = scorez.look[0]
  sleeps = scorez.look[-1]
  puts scorez.reduce(0){|s,a| s+=a[-1]}

  puts score

  at{
    v=0.8
#    callstack score[0], 114*v, sus: 8
    sleep 1.0
 #   operator score[1], (ing 100, 100, 50, 30).tick(:i), sus: (ing 1 0.25 0.25).tick(:s)
    sleep 2
    sleep 1.0
  }

  # at{
  #   sleeps.times{
  #     #operator score[-1], (ing 100, 100, 50, 30).tick(:i), sus: (ing 1 0.25 0.25).tick(:s)
  #     sleep (ing
  #            1/2.0
  #            1/4.0 1/4.0
  #            ).tick(:n)
  #     #ze score[-1], 25
  #   }
  #   if score[0] == :C3
  #     score[0] = :C4
  #   end
  #   if score[0] == nil
  #     at{
  #       #overclock :G4, 40, sus: 1.0
  #       sleep 1+0.125
  #       #qbitsea :G3, sus: 32
  #     }
  #   else
  #     #overclock score[0], 100, sus: 1.0
  #   end
  # }
  #qbitsea_cc oct: (ing 0 7 0 12+5).look
  heat score[0], 0.5*(ing 10 30 50 10  10 30 40 50).look, sus: sleeps, pads: [0,1,2], sat: 0.0, drive: 0.00
  # heat score[1], 2*(ing 10 30 50 10  10 30 40 50).look, sus: sleeps, pads: [1], sat: 0.0, drive: 0.00
  # heat score[2], 2*(ing 10 30 50 10  10 30 40 50).look, sus: sleeps, pads: [2], sat: 0.0, drive: 0.00
  # heat score[3], 2*(ing 10 30 50 10  10 30 40 50).look, sus: sleeps, pads: [2], sat: 0.0, drive: 0.00

  # with_transpose 12{
  #   callstack score[0],127, sus: 16
  #   sleep 0.125/2.0
  #   callstack score[1],127, sus: 16
  #   sleep 0.125/2.0

  #   callstack score[2],127, sus: 16

  #   sleep 0.125/2.0
  #   callstack score[3],127, sus: 16
  #   sleep 0.125/2.0

  # }

  #deep root(score), 127, sus: sleeps*2, drive: 0.0, sat: 0.0
  sleep sleeps
end

#overclock_on :E3

#deep_cc dirt: 1.0, wet: 1.0, tone: 1.0, filter: 1.0
#heat_cc solo: 1.0

live_loop :pace, sync: :unsyncable do; tick
#  overclock_cc oct: (ing 0,  -12, 0, 12).look
  sleep 0.25
  tick
#  overclock_cc oct: (ing 0,  -12, 0, 19).look
  sleep 1
end

#overclock_cc oct: 12
#overclock_cc motion: 0.00, drive: 1.00, sat: 0.00

live_loop(:unsyncable) do
  sleep 1.0
end

#drums on: 1.0
#lfo on: false, cutoff: 0.10
#hfp on: true, cutoff: 0.00

#mbox_cc motion: 0.30, drive: 1.00, sat: 1.00
#mbox2_cc motion: 0.00, drive: 0.00
