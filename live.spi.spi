live_loop(:metro)do
  tick;

  # clock_midi
  cue("16") if look % 16 == 0
  cue("32") if look % 32 == 0
  cue("64") if look % 64 == 0
  #  midi_clock_tick port: :iac_bus_1 #channel: 3, port: :iac_bus_1
  midi_start if tick == 0 # Send a midi_start event the first time round the live loop only
  midi_clock_beat 0.5 #port: :iac_bus_1#, chaneel: 1         # this will not just send a steady clock beat, but also ensure
  #smp Mountain[/subkick/,1]
  sleep 1
end

live_loop :test, sync: :metro do
  tick
  use_real_time
#  midi_note_on (scale :A2, :major, octaves: 3).shuffle.look, port: "*"
  sleep 1/4.0
end


live_loop :music, sync: :metro do
  tick
  #sync "16"
  use_real_time
  harp (ring [:A3,3], [:Cs3,3], [:B3, 3]).look, 10.0, sustain: 8.0, port: :iac_bus_1, channel: 9
  #bass :E2, sustain: 3
  #harp_cc phase: rand
#  sleep 3
  #  harp_cc phase: 1.0

  sleep 3

  8.times{
    midi_pitch_bend 2, port: :iac_bus_1, channel: 9
#    sleep 1/4.0
    #pitch wheel.

    # midi_cc 108, 12, port: :iac_bus_1, channel: 9
    # midi_cc 109, 12, port: :iac_bus_1, channel: 9
    # midi_cc 110, 12, port: :iac_bus_1, channel: 9
    # midi_cc 111, 12, port: :iac_bus_1, channel: 9

    #midi_cc (line 0, 127).look, 127,  port: :iac_bus_1, channel: 9
    tick

    #midi_cc 1, (line 0, 127).look,  port: :iac_bus_1, channel: 9
#    tick
  }

end

with_fx :reverb do
  live_loop :pattern, sync: :metro do
    stop
    tick
    #sync "16"
    c1 = Dust[/clap/,1]
    k1,k2,k3 = Frag[/kick/,9], Mountain[/subkick/,0], (knit Dust[/kick/,24],3, Dust[/kick/,25],3).look
    s=(ring *%W{
     k2 _ _ _   k1 _ _ _   k1 _ _ _
     k1 _ _ _   k1 _ _ _   k1 _ _ _

     k2 _ _ _   k1 _ _ _   k1 _ _ _
     k1 _ _ _   k1 _ _ _   k1 _ _ _

     k2 _ {path:k2,amp:1.1} _  k1 _ _ _   k1 _ _ _
     k1 _ _ _   k1 _ _ _   Fraz[/kick/].tick(:kicks) _ k2 _
  }).look
    smp eval(s), amp: (line 0.8, 1.0, 12*6).look

    p = Dust[/perc/,/conga/].look
    s=(ring *%W{
p _ _ _   _ _ p _
_ _ p _

_ _ p _   _ _ p _
_ _ p _
}).look
  smp eval(s), cutoff: (line 80, 120, 6*4).look

    c = MagicDust[/HI_/, [54,55]].look
    if (s=(ring *%W{
_ _ _ _    _ _
_ _ _  _ _ _
_ _ _  _ _ _
_ _ _  _ _ _
}).look) != _
      smp eval(s)
    end

  c1 = MagicDust[/HI_/].look#, Dust[/clap/].look
  s=(ring *%W{
 _ _ _ _   c1 _ _ _   _ _ _ _   c1 _ _ _
 _ _ _ _   c1 _ _ _   _ _ _ _   c1 _ _ _

 _ _ _ _   c1 _ _ _   _ _ _ _   c1 _ _ _
 _ _ _ _   c1 _ _ _   _ _ _ _   c1 _ _ _
}).look
#  smp eval(s), amp: 2.0

 # = spread(7,11).map{|s| s ? :hit : :miss}
  s=(ring *%W{_ _ _ _   c2 _ _ _}).look
 # smp eval(s), cutoff: (line 80, 120, 128).look

  h,h2 = Fraz[/hat/,0],Frag[/hat/,6]

  s=(ring *%W{
_ _ h _                     _ _ h _
_ _ h _                     _ _ h _
_ _ h {path:h,amp:0.25}     _ _ h _
_ _ h _                     _ _ h _
_ _ h _                     {path:h2,amp:0.9} _ h _

}).look
#  smp eval(s)

  sleep 1/8.0
end
end
