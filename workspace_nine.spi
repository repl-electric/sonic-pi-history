def deg_seq(*pattern_and_roots)
  pattern_and_roots = pattern_and_roots.flatten
  pattern_and_roots = pattern_and_roots.map{|pat|
    if pat =~ /\*/
      note, factor = pat.split("*")
      ([note] * factor.to_i).join("")
    else
      pat
    end
  }.flatten

  pattern_and_roots = pattern_and_roots.reduce([]){|accu, id|
    if(/^[-\d_]+$/ =~ accu[-1] && /^[-\d_]+$/ =~ id)
      accu[0..-2] << "#{accu[-1]}#{id}"
    else
      accu << id
  end}
  patterns = pattern_and_roots.select{|a| /^[-\d_]+$/ =~ a.to_s }
  roots   = pattern_and_roots.select{|a| /^[-\d_*]+$/ !~ a.to_s}

  notes = patterns.each_with_index.map do |pattern, idx|
    root = roots[idx]
    if(root[0] == ":")
      root = root[1..-1]
    end
    s = /[[:upper:]]/.match(root.to_s[0]) ? :major : :minor
    if(s == :minor)
      s = if    root.to_s[1] == "h"
        :harmonic_minor
      elsif root.to_s[1] == "m"
        :melodic_minor
      else :minor
      end
    end
    #MESSEY
    root = root[0..1] + root[2..-1] if root.length > 2
    puts pattern
    
    pattern.
      scan(/(\d{1}|-\d{1})/).
      flatten.
      map{|d| 
        if(d == "_" )
           nil
        elsif(d.to_i < 0)
           puts root[-1]-1
#           root = root[0..-2] + (root[-1].to_i.to_i - 1)
           puts root
           degree(d.to_i.abs, root, s)
        else
           degree(d.to_i, root, s)
        end}
  end.flat_map{|x| x}
 (ring *notes)
end

puts deg_seq(%w{Fs4 34  -3  4})

#puts degree(0, :F3, :major) 

#puts -7.to_i