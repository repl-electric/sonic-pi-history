["experiments.rb", "log.rb"].each{|f| load "/Users/josephwilk/Workspace/repl-electric/live-coding-space/lib/#{f}"}
_ = nil
bar = 1.0
use_bpm 60
set_volume! 1.0
@polyrhythm = [2,3]
load_snippets("~/.sonic-pi/snippets/")

live :next, amp: 0.5 do
  density(@polyrhythm.sort.first) do
    sample Mountain["pebble",0], start: rrand(0.0,0.01), rate: -1.0, amp: 0.4
    sleep bar
  end
end

live :indeterminism, amp: 1.0 do
  4.times{sync :next}

    with_fx(:distortion, mix: 1.0, distort: 0.8) do |fx_r|
      with_synth(:hollow) do
        play deg_seq(%w{Fs4 1 3}).tick, decay: bar*2, attack: 4, amp: 0.2, release: 1.0
      end
      4.times{
        sleep bar/4.0
        control fx_r, distort: (ring 0.8, 0.8, 0.5, 0.0).tick(:distory)
      }
    end

  4.times{sync :next}
  i_deter(deg_seq(%w{Fs4 1*7 _ 3*7 _}).tick,
          deg_seq(%w{Fs4 34 -5 4}).stretch(4).tick)
end


live_loop :melody do;
with_fx(:level, amp: 0.4) do
  sync :next
  4.times{
    pattern = (knit degree(1, :Fs4, :major), 1,
                    degree(3, :Fs4, :major), 1,
                    (dice(6) > 3 ? degree(4, :Fs4, :major) : degree(5, :Fs4, :major)), 1,
                    degree(6, :Fs4, :major), 1,

                     _, 4,
                    degree(1, :Fs3, :major), 1,
                    degree(3, :Fs3, :major), 1,
                    (dice(6) > 3 ? degree(4, :Fs4, :major) : degree(5, :Fs4, :major)), 1,
                    degree(6, :Fs4, :major), 1,
                     _, 4,

                    degree(1, :Fs3, :major), 1,
                    degree(3, :Fs3, :major), 1,
                    (dice(6) > 3 ? degree(1, :Fs3, :major) : degree(3, :Fs3, :major)), 1,
                    degree(6, :Fs3, :major), 1,
                     _, 4,

                    degree(5, :Fs3, :major), 8,
                    degree(3, :Fs3, :major), 8,

                    (dice(6) > 3 ? degree(1, :Fs3, :major) : degree(3, :Fs3, :major)), 1,
                    degree(1, :Fs4, :major), 1
)
    note = pattern.tick(:notes)

    with_transpose(0) do
      with_synth(:hollow) do

          f = if(note == degree(5, :Fs4, :major))
            :echo
          else
            :none
          end

          with_fx(f) do
            i_nil note, release: 8.0
          end

          if note == degree(5,:Fs4,:major)
            with_synth(:dark_ambience) do
              with_transpose(-2) do
                play note, attack: 1.0, release: 2.0, decay: 3.0 
              end
            end
          end

            with_synth(:dark_ambience) do
              with_transpose(-12) do
                play note, attack: 0.5, release: 1.0, decay: 3.0 
              end
            end

          
      end
    end
    sleep bar/2.0
  }
end
end

with_fx :distortion, mix: 0.1 do
  with_fx(:pitch_shift, window_size: 4.0) do
    live_loop :rumbling_loops, auto_cue: false do |idx|;with_fx :level, amp: 0.5 do
        with_fx :reverb, mix: 0.2, damp: 0.3 do |fx_reverb|;
          3.times{sync :next}
          note = (ring :B1, :Cs1, :Ds1,
                       :B1, :Cs1, :Ds1,
                       :B1, :Cs1, :Fs2).tick(:a)

          puts "BASS[#{note_info(note||0)}]"

          sleep bar/2.0

          (ring 1,0).tick(:double).times do
            with_synth [:pnoise, :prophet][0] do
              play note, amp: 0.7, release: (knit bar,1).tick(:Bass), attack: 0.01, cutoff: 60
            end
          end

          1.times{sync :next}

          i_bass(note)

          6.times{
            control fx_reverb, damp: (rrand 0.0,1.0)
            sleep bar/8.0
          }
        end
      end
      idx+=1
    end
  end
end

live_loop :drums do
  2.times{sync :next}
  sample Mountain[/subkick/i, 2..4].tick, amp: 0.3
end

live_loop(:drum_timing_loop, auto_cue: false){sync :next;density(2){ 16.times{ cue :drum_hit; sleep (4.0/16.0)}}}
def ring_gen(n, fn)
  (ring *((0..n).map{fn.()}))
end

drum_loop(:perc3,  (ring *%w{x - - - - - - -
                             - - - - - - - -
                             - - - - - - - -
                             - - - - - - x -
}), Ether[/click/i,2], amp: 0.2, rate: 1.0, start: ring_gen(32, lambda{rrand(0.0,0.1)}))