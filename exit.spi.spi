REST=[[[_, 0.25]], 1];use_bpm 63.5
live_loop :Fall_out_of_your_screen do tick;
  live_loop :Within_the_letters{stop}

  score =  (ing  #15.25
    [[[:b2 2]   [:ds5 2]    [:fs3 2]]           2]   REST
    [[[:fs2 4]  [:gs4 2.0]  [:cs3 4]]           2]   REST
    [[[:a2 2]   [:b3 2]   [:e4 2]]            2]     REST
    [[[:d2 2]   [:fs3 1]   [:as2 1]]            2]   REST
  #  [[[:fs2 4] [:a3 1.0]  [:cs3 4]]           2]   REST


#    [[[:e2 2]  [:gs4 2]  [:b3 2]]  2]
#    [[[:b2 2]  [:d5 2]   [:fs3 2] [:cs4 2]]  2]                  REST
#    [[[:fs4 2] [:A4 2]   [:Cs3 2] ]  2]                          REST
    )
  cue :kernel_panic
  s=score.look;;c=s[0];zzz=s[-1]
  whitespace c[0][0], sus: 12
  if spread(1,6).look
    #rev :b5, 1
    #eek :Gs3, 10
  end
  #rev :a6, 15, sus: 12
  if !c[0][0]
    eek (ing :e4 :gs4 :e4 :b4 _ _).look, (ing 100 120).look(:missing), sus: 3.0, at: 0.0, mod: 0.0, mode: 2
  end
  with_transpose -12 {cpu2 c[1], 60, sus: 2 }
  c.each_tick(:inner){|n|
    qbitsea n,2.0*(ing 80 70 85 70).look(:inner), mode: 0, cutoff: 1.0, phase: 0, comp: 0
  }

  pf=0.2
  i=(method :callstack)
  i.call(c[0], 60*pf, sus: 4)
  i.call(c[1], 50*pf, sus: 4)
  i.call(c[2], 55*pf, sus: 4)
  i.call(c[3], 70*pf, sus: 2)
  i.call(c[4], 30*pf, sus: 8)
  i.call(c[5], 30*pf, sus: 8)

  exception root(c), 127, sus: 2#, shape: 1.0, : #, wet: 0.1, more: 0.0, shape: 0.8, atk: 0.2
  null root(c), 127*0.5, mode: 2

  8.times{tick(:in2);
    callstack (ing
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :fs5 _   _   :fs5 :a4 _
          :a5 _ :e5 _    _   :cs6 :a4 _
          :a5 _ :a4 _   :e5  :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    _   :b5  :a4 _
          :a5 _ :a4 _    :e6 :b5  :a4 _
          ).look(:in2), (ing 90 90 80 80 70 70 60 60).look(:in2)*1.0
    sleep zzz/8.0
  }
end

live_loop :ag, sync: :Fall_out_of_your_screen do
  tick
  smp Mountain[/subkick/,1], amp: 2
  if spread(1,2).look
    if spread(1,3).look
      smp TS[49]
    else
    smp TS[12]
    end

  end

    p=(ing
      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      [TS[49]] _ _ TS[12]    _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TT[49] _ _ TS[12]      _ _ _ _

      _ _ _ _                _ _ _ _
      _ _ _ _                _ _ _ _
      TS[7] _ _ _            _ _ _ _
      )

    p=p.look
    #p=_
    fx=:lpf
    accent = (ing 0.2 0.2 0.3 0.5).look
    attack = 0.0
    r = 1.0
    if p && p.is_a?(Array)
      p = p[0]
      accent=accent*1.5
    end
    if p
      with_swing(0.01) do
        with_fx(fx, phase: (ring 1/4.0,1/4.0,1/8.0).look){
          smp p, amp: 3*accent, rate: r, attack: attack
        }
      end
    end


  sleep 1/2.0
end
