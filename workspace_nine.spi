["experiments.rb", "log.rb"].each{|f| load "/Users/josephwilk/Workspace/repl-electric/live-coding-space/lib/#{f}"}
#                        \:o/ - nil.music.lights
#   π=-    π=-   π=-      █
#  π=-   π=-   π=-      .||.
_ = nil
bar = 1.0
use_bpm 60
set_volume! 3.0
@polyrhythm = [2,3]
load_snippets("~/.sonic-pi/snippets/")

live :next, amp: 0.5 do
  density(@polyrhythm.sort.first) do
    sample Mountain["pebble",0], start: rrand(0.0,0.01), rate: -1.0, amp: 0.4
    sleep bar
  end
end

live :indeterminism, amp: 2.0 do
  4.times{sync :next}
 
  uncomment do
  with_fx(:distortion, mix: 1.0, distort: 0.8) do |fx_r|
  with_synth(:hollow) do
  play deg_seq(%w{Fs4 1 3}).tick, decay: bar*2, attack: 4, amp: 0.2, release: 1.0
  end
  4.times{
    sleep bar/4.0
    control fx_r, distort: (ring 0.8, 0.8, 0.5, 0.0).tick(:distory)
  }
  end
  end

  4.times{sync :next}
  i_deter(deg_seq(%w{Fs4 1*7 _ 3*7 _}).tick,
          deg_seq(%w{Fs4 34 -5 4}).stretch(4).tick)
end

live :drifting_through_code, amp: 2.0 do
  1.times {sync :next}
  density(@polyrhythm.sort.last) do
  with_fx :reverb, room: 1.0, mix: 1.0, damp: 0.1 do |fx_r|
    with_fx((knit :none,7, :echo,(ring 7).tick(:d)).tick(:r2), mix: 0.8, phase: bar/2.0) do
notes = (knit chord(:As3,:m)[0..1], 12,
              chord(:As3,:m),       12,
              chord(:Cs3,:M, invert: 2).delete_at(1), 12,
              chord(:Cs3,:M, invert: 1), 12,
              chord(:Ds4,:m, invert: -2), 20,
              _, 4,
              chord_degree(7, :Fs3, :major, 3, invert: -2), 20,
              _, 4,
              chord(:Es3,'dim', invert: 1), 10,
              chord(:Es3,'dim', invert: 1), 10,
              _, 4,
              dice(6) > 6 ? chord(:Fs3,'sus4', invert: -1) : chord(:Fs3,'sus4', invert: 0), 20,
              _, 4,
              chord(:Fs3,:M, invert: -1), 20,
              _, 4,
              chord(:B4,:M, invert: -2)[0..2], 10,
              chord(:B4,:M, invert: -3)[0..2], 10,
              _, 4)

n = notes.tick(:asb)
#n = chord(:Fs3, 'sus4') + chord(:Fs3, "M") + chord(:As3, 'sus4') + chord(:As3, 'M')
#n = [chord_seq(*%w{Cs3 7 Fs3 M B3 M7}).ring.stretch(2).tick(:notes)]
#n =  chord_seq(*%w{˘Cs3 7 Fs3 M B3 M7}).ring
n = knit(chord(:Fs4, 1),2, chord(:Fs4, 1),2, chord(:B4, 1),2).tick(:yum)
#n = (knit chord(:Cs3, :M7), 2, _, 1).tick(:n)

#n = [degree(3, :Fs4, :major)]

#puts "Harmony[#{(n||[]).map{|n| note_info(n).midi_string}}]"

if (n||[]).map{|a|note_info(a).midi_string} == (ring "Fs4", "B4", "Eb4")
  cue :bhit
end
#with_transpose(-12){with_synth(:sine){play (n ? n.sort[0] : n), cutoff: 60, pan: (Math.sin(vt*13)/1.5), amp: (ring 0.25).tick(:sdf), decay: 0.1 + rrand(0.1,0.2), release: 0.01}}
     # i_int(n)
      #i_float(n)

      sleep bar
end;end;end;end

live_loop :melody do
sync :next 

with_synth(:dsaw){
  play chord(:Fs1, "dim"), decay: bar*2, cutoff: 100,  sustain_level: 0.5
}

4.times{
with_transpose(-12) do
uncomment do
with_fx(:bitcrusher, sample_rate: 20000, bits: 12.0, mix: 0.0, mix_slide: 2.0) do
with_synth(:hollow) do

pat = [
#     degree(1, :Fs4, :major), 1,
#       degree(3, :Fs4, :major), 1,
#      (dice(6) > 3 ? degree(4, :Fs4, :major) : degree(5, :Fs4, :major)), 1,
#       degree(6, :Fs3, :major), 1,

#       degree(1, :Fs4, :major), 1,
#       degree(3, :Fs4, :major), 1,
#      (dice(6) > 3 ? degree(4, :Fs4, :major) : degree(5, :Fs4, :major)), 1,
#       degree(6, :Fs3, :major), 1,

      degree(1, :Fs3, :major), 3,
      degree(4, :Fs3, :major), 1,
      degree(5, :Fs3, :major), 4,
      degree(6, :Fs3, :major), 8,

      _, 8,
      
      degree(1, :Fs3, :major), 3,
      degree(3, :Fs3, :major), 1,
      degree(5, :Fs3, :major), 4,
      degree(6, :Fs3, :major), 8
]

x = (knit *pat)


#                degree(1, :Fs4, :major),
                 #degree(7, :Fs3, :major)
x.tick

def note_inspect(n,ns="")
  n = [n] unless n.respond_to?(:map)
  if n
    "#{ns}[#{(n||[]).map{|n| n ? note_info(n).midi_string : "_"}}]"
  else
    "#{ns}[ _ ]"
  end
end

puts note_inspect(x.look, "Harmony:")


f = if(x.look == degree(5, :Fs4, :major))
  :echo
else
  :none
end     
with_fx(f) do
    i_nil x.look, release: 8.0

if f == :echo
with_synth(:dark_ambience) do
  #with_transpose(-3){play x.look, release: 4.0, attack: 1.0, amp: 2.0, noise: 0, ring: 0.2, room: 300, reverb_time: 200}
end
end
end

with_fx(:reverb, room: 1.0, mix: 0.9, room_lag: 1.0) do |fx_reverb|
case x.look
when degree(6, :Fs3, :major)
with_synth(:dsaw) do
#  play degree(3, :Fs3, :major), attack: 0.01, amp: 0.2, release: bar*1, res: 0.5, cutoff: 60
end
with_transpose(12) do
  with_fx :slicer, mix: 0.2 do
 with_fx :pitch_shift do
with_synth(:prophet) do
 #play x.look, attack: 0.01, amp: 0.5, release: bar*0.3
end
#end
end
end
end

control fx_reverb , room: 0.0, mix: 0.8
sleep bar/8.0
control fx_reverb , room: 0.1, mix: 0.9
sleep bar/8.0
control fx_reverb , room: 0.2, mix: 0.8
sleep bar/8.0
control fx_reverb , room: 0.5, mix: 0.7
sleep bar/8.0
control fx_reverb , room: 1.0, mix: 0.9

end
end
end


end
end
comment do
with_synth(:hollow) do
    i_nil (ring degree(1, :Fs4, :major),
                degree(3, :Fs4, :major),
                (dice(6) > 3 ? degree(6, :Fs3, :major) : degree(4, :Fs3, :major)),
                 degree(3, :Fs3, :major),
#                degree(1, :Fs4, :major),
                 #degree(7, :Fs3, :major)
).tick, release: 8.0
end
end



end
sleep bar/2.0
}

end


live :recursion, amp: 0.0 do
  9.times{sync :bhit}
end

with_fx :distortion, mix: 0.1 do
with_fx(:pitch_shift, window_size: 4.0) do
live_loop :rumbling_loops, auto_cue: false do |idx|;with_fx :level, amp: 0.5 do
with_fx :reverb, mix: 0.2, damp: 0.3 do |fx_reverb|;
    3.times{sync :next}
comment do
    notes = (knit "Cs3",2, "Gs2",2, "As2",2,
                  "Cs3",2, "Gs2",2, "As2",2,
                  "B2",2,  "Gs2",2, "As2",2)
end

    notes = (knit chord(:As1,:m,    invert: 2)[0], 1,
                  :Cs2,                            2,
                  chord(:Ds2,:m,    invert: 0)[0], 2,
                  chord(:Es1, 'dim',invert: 0)[0], 2,
                  chord(:Es1,'dim', invert: 2)[0], 2,
                  :Fs1,                            2,
                  _,1,:Fs2,1,
                  chord(:B1,:M,     invert: -1)[0],3)

    note = notes.tick(:a)

    note = (ring :B1, :Cs2, :Ds2,
                 :B1, :Cs2, :Ds2,
                 :B1, :Cs2, :Fs2).tick(:a)

    puts note_inspect(note, "Bass")

    sleep bar/2.0
    #(ring 1,0).tick(:ti).times{with_fx(:pitch_shift, mix: 1.0, pitch: 0.025){with_fx(:slicer, mix: 0.5, phase: 0.025, probability: 0.5){sample Heat[/stacked_bells/i,note_to_sample(notes.reverse.look(:a),1)], amp: 1.5, attack: 0.2}}}
    #(knit 1,1).tick(:heat).times {with_fx(:reverb){sample Heat[/low_pad/i,note_to_sample(note,1)], amp: 1.0}}

    (ring 1,0).tick(:double).times do
      #with_fx(:echo, decay: 2.0){sample Frag[/coil/i, /f#/i].tick(:coil), amp: 0.5}
      #sample Frag[/coil/i,11], amp: 1.0
      with_synth [:pnoise, :prophet][0] do
      play note, amp: 0.7, release: (knit bar,1).tick(:Bass), attack: 0.01, cutoff: 60
    end
    end

    1.times{sync :next}

    i_bass(note)

    6.times{
      control fx_reverb, damp: (rrand 0.0,1.0)
      sleep bar/8.0
    }
end;end
idx+=1
end;end;end

live :missing_semi_colon, amp: 0.0 do
    2.times{sync :start}
    sample (knit Mountain["microperc_06"],3,Mountain["microperc_07"],1).tick(:s)
end